/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	// Generated by BUCKLESCRIPT VERSION 1.9.3, PLEASE EDIT WITH CARE
	'use strict';

	var Std               = __webpack_require__(1);
	var Js_primitive      = __webpack_require__(24);
	var Http$BsSentiaHttp = __webpack_require__(25);

	function onError(e) {
	  if (typeof e === "number") {
	    if (e !== 0) {
	      console.log("NetworkError");
	      return /* () */0;
	    } else {
	      console.log("Timeout");
	      return /* () */0;
	    }
	  } else {
	    console.log("BadResponse", e[0], e[1]);
	    return /* () */0;
	  }
	}

	function onSuccess(d) {
	  console.log(d);
	  return /* () */0;
	}

	var query = "\n  {\n    authenticate(email: \"andreas@sentia.io\", password: \"password\") {\n      token\n    }\n  }\n";

	var payload = {
	  query: query,
	  variables: {
	    session: ""
	  }
	};

	var body = Std.Option[/* withDefault */7]("", Js_primitive.undefined_to_opt(JSON.stringify(payload)));

	Std.Task[/* fork */11](onError, onSuccess, Http$BsSentiaHttp.post(/* None */0, body, "https://gain.ai:8090/graphql"));

	exports.onError   = onError;
	exports.onSuccess = onSuccess;
	exports.query     = query;
	exports.payload   = payload;
	exports.body      = body;
	/* body Not a pure module */


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	// Generated by BUCKLESCRIPT VERSION 1.9.3, PLEASE EDIT WITH CARE
	'use strict';

	var List                    = __webpack_require__(2);
	var Block                   = __webpack_require__(7);
	var Curry                   = __webpack_require__(3);
	var Js_exn                  = __webpack_require__(20);
	var $$String                = __webpack_require__(21);
	var Caml_obj                = __webpack_require__(6);
	var Pervasives              = __webpack_require__(8);
	var Caml_string             = __webpack_require__(16);
	var Caml_builtin_exceptions = __webpack_require__(5);

	function identity(a) {
	  return a;
	}

	function always(a, _) {
	  return a;
	}

	function $$void() {
	  return /* () */0;
	}

	function $great$great(f, g, x) {
	  return Curry._1(g, Curry._1(f, x));
	}

	function flip(f, a, b) {
	  return Curry._2(f, b, a);
	}

	function curry(f, a, b) {
	  return Curry._1(f, /* tuple */[
	              a,
	              b
	            ]);
	}

	function uncurry(f, param) {
	  return Curry._2(f, param[0], param[1]);
	}

	function tap(f, a) {
	  Curry._1(f, a);
	  return a;
	}

	function some(a) {
	  return /* Some */[a];
	}

	function map(f, opt) {
	  if (opt) {
	    return /* Some */[Curry._1(f, opt[0])];
	  } else {
	    return /* None */0;
	  }
	}

	function map2(f, opt1, opt2) {
	  if (opt1 && opt2) {
	    return /* Some */[Curry._2(f, opt1[0], opt2[0])];
	  } else {
	    return /* None */0;
	  }
	}

	function map3(f, opt1, opt2, opt3) {
	  if (opt1 && opt2 && opt3) {
	    return /* Some */[Curry._3(f, opt1[0], opt2[0], opt3[0])];
	  } else {
	    return /* None */0;
	  }
	}

	function flatten(opt) {
	  if (opt) {
	    return opt[0];
	  } else {
	    return /* None */0;
	  }
	}

	function flatMap(f, opt) {
	  if (opt) {
	    return Curry._1(f, opt[0]);
	  } else {
	    return /* None */0;
	  }
	}

	function withDefault(defaultValue, opt) {
	  if (opt) {
	    return opt[0];
	  } else {
	    return defaultValue;
	  }
	}

	function fromResult(res) {
	  if (res.tag) {
	    return /* Some */[res[0]];
	  } else {
	    return /* None */0;
	  }
	}

	function fromRemote(res) {
	  if (typeof res === "number" || res.tag !== 1) {
	    return /* None */0;
	  } else {
	    return /* Some */[res[0]];
	  }
	}

	function isNone(opt) {
	  if (opt) {
	    return /* false */0;
	  } else {
	    return /* true */1;
	  }
	}

	function isSome(opt) {
	  if (opt) {
	    return /* true */1;
	  } else {
	    return /* false */0;
	  }
	}

	var Option = /* module */[
	  /* some */some,
	  /* none : None */0,
	  /* map */map,
	  /* map2 */map2,
	  /* map3 */map3,
	  /* flatten */flatten,
	  /* flatMap */flatMap,
	  /* withDefault */withDefault,
	  /* fromResult */fromResult,
	  /* fromRemote */fromRemote,
	  /* isNone */isNone,
	  /* isSome */isSome
	];

	function ready(a) {
	  return /* Ready */Block.__(1, [a]);
	}

	function error(x) {
	  return /* Failed */Block.__(0, [x]);
	}

	function map$1(f, remote) {
	  if (typeof remote === "number") {
	    if (remote) {
	      return /* Pending */1;
	    } else {
	      return /* NotAsked */0;
	    }
	  } else if (remote.tag) {
	    return /* Ready */Block.__(1, [Curry._1(f, remote[0])]);
	  } else {
	    return /* Failed */Block.__(0, [remote[0]]);
	  }
	}

	function map2$1(f, r1, r2) {
	  if (typeof r1 === "number") {
	    if (r1) {
	      return /* Pending */1;
	    } else {
	      return /* NotAsked */0;
	    }
	  } else if (r1.tag) {
	    if (typeof r2 === "number") {
	      if (r2) {
	        return /* Pending */1;
	      } else {
	        return /* NotAsked */0;
	      }
	    } else if (r2.tag) {
	      return /* Ready */Block.__(1, [Curry._2(f, r1[0], r2[0])]);
	    } else {
	      return /* Failed */Block.__(0, [r2[0]]);
	    }
	  } else {
	    return /* Failed */Block.__(0, [r1[0]]);
	  }
	}

	function map3$1(f, r1, r2, r3) {
	  if (typeof r1 === "number") {
	    if (r1) {
	      return /* Pending */1;
	    } else {
	      return /* NotAsked */0;
	    }
	  } else if (r1.tag) {
	    if (typeof r2 === "number") {
	      if (r2) {
	        return /* Pending */1;
	      } else {
	        return /* NotAsked */0;
	      }
	    } else if (r2.tag) {
	      if (typeof r3 === "number") {
	        if (r3) {
	          return /* Pending */1;
	        } else {
	          return /* NotAsked */0;
	        }
	      } else if (r3.tag) {
	        return /* Ready */Block.__(1, [Curry._3(f, r1[0], r2[0], r3[0])]);
	      } else {
	        return /* Failed */Block.__(0, [r3[0]]);
	      }
	    } else {
	      return /* Failed */Block.__(0, [r2[0]]);
	    }
	  } else {
	    return /* Failed */Block.__(0, [r1[0]]);
	  }
	}

	function flatten$1(r) {
	  if (typeof r === "number") {
	    if (r) {
	      return /* Pending */1;
	    } else {
	      return /* NotAsked */0;
	    }
	  } else if (r.tag) {
	    return r[0];
	  } else {
	    return /* Failed */Block.__(0, [r[0]]);
	  }
	}

	function flatMap$1(f, remote) {
	  if (typeof remote === "number") {
	    if (remote) {
	      return /* Pending */1;
	    } else {
	      return /* NotAsked */0;
	    }
	  } else if (remote.tag) {
	    return Curry._1(f, remote[0]);
	  } else {
	    return /* Failed */Block.__(0, [remote[0]]);
	  }
	}

	function withDefault$1(a, rem) {
	  if (typeof rem === "number" || rem.tag !== 1) {
	    return a;
	  } else {
	    return rem[0];
	  }
	}

	function fromResult$1(res) {
	  if (res.tag) {
	    return /* Ready */Block.__(1, [res[0]]);
	  } else {
	    return /* Failed */Block.__(0, [res[0]]);
	  }
	}

	function fromOption(opt) {
	  if (opt) {
	    return /* Ready */Block.__(1, [opt[0]]);
	  } else {
	    return /* NotAsked */0;
	  }
	}

	function isNotAsked(remote) {
	  if (typeof remote === "number" && remote === 0) {
	    return /* true */1;
	  } else {
	    return /* false */0;
	  }
	}

	function isPending(remote) {
	  if (typeof remote === "number" && remote !== 0) {
	    return /* true */1;
	  } else {
	    return /* false */0;
	  }
	}

	function isFailed(remote) {
	  if (typeof remote === "number" || remote.tag) {
	    return /* false */0;
	  } else {
	    return /* true */1;
	  }
	}

	function isReady(remote) {
	  if (typeof remote === "number" || remote.tag !== 1) {
	    return /* false */0;
	  } else {
	    return /* true */1;
	  }
	}

	function map$2(f, res) {
	  if (res.tag) {
	    return /* Ok */Block.__(1, [Curry._1(f, res[0])]);
	  } else {
	    return /* Error */Block.__(0, [res[0]]);
	  }
	}

	function map2$2(f, r1, r2) {
	  if (r1.tag) {
	    if (r2.tag) {
	      return /* Ok */Block.__(1, [Curry._2(f, r1[0], r2[0])]);
	    } else {
	      return /* Error */Block.__(0, [r2[0]]);
	    }
	  } else {
	    return /* Error */Block.__(0, [r1[0]]);
	  }
	}

	function map3$2(f, r1, r2, r3) {
	  if (r1.tag) {
	    if (r2.tag) {
	      if (r3.tag) {
	        return /* Ok */Block.__(1, [Curry._3(f, r1[0], r2[0], r3[0])]);
	      } else {
	        return /* Error */Block.__(0, [r3[0]]);
	      }
	    } else {
	      return /* Error */Block.__(0, [r2[0]]);
	    }
	  } else {
	    return /* Error */Block.__(0, [r1[0]]);
	  }
	}

	function flatten$2(r) {
	  if (r.tag) {
	    return r[0];
	  } else {
	    return /* Error */Block.__(0, [r[0]]);
	  }
	}

	function flatMap$2(f, res) {
	  if (res.tag) {
	    return Curry._1(f, res[0]);
	  } else {
	    return /* Error */Block.__(0, [res[0]]);
	  }
	}

	function withDefault$2(a, res) {
	  if (res.tag) {
	    return res[0];
	  } else {
	    return a;
	  }
	}

	function fromOption$1(err, opt) {
	  if (opt) {
	    return /* Ok */Block.__(1, [opt[0]]);
	  } else {
	    return /* Error */Block.__(0, [err]);
	  }
	}

	function isError(res) {
	  if (res.tag) {
	    return /* false */0;
	  } else {
	    return /* true */1;
	  }
	}

	function isOk(res) {
	  if (res.tag) {
	    return /* true */1;
	  } else {
	    return /* false */0;
	  }
	}

	var Result = /* module */[
	  /* map */map$2,
	  /* map2 */map2$2,
	  /* map3 */map3$2,
	  /* flatten */flatten$2,
	  /* flatMap */flatMap$2,
	  /* withDefault */withDefault$2,
	  /* fromOption */fromOption$1,
	  /* isError */isError,
	  /* isOk */isOk
	];

	function reverse(xs) {
	  var _acc = /* [] */0;
	  var _xs = xs;
	  while(true) {
	    var xs$1 = _xs;
	    var acc = _acc;
	    if (xs$1) {
	      _xs = xs$1[1];
	      _acc = /* :: */[
	        xs$1[0],
	        acc
	      ];
	      continue ;
	      
	    } else {
	      return acc;
	    }
	  };
	}

	function isEmpty(xs) {
	  if (xs) {
	    return /* false */0;
	  } else {
	    return /* true */1;
	  }
	}

	function foldLeft(f, _acc, _xs) {
	  while(true) {
	    var xs = _xs;
	    var acc = _acc;
	    if (xs) {
	      _xs = xs[1];
	      _acc = Curry._2(f, xs[0], acc);
	      continue ;
	      
	    } else {
	      return acc;
	    }
	  };
	}

	function foldRight(f, acc, xs) {
	  if (xs) {
	    return Curry._2(f, xs[0], foldRight(f, acc, xs[1]));
	  } else {
	    return acc;
	  }
	}

	function foldLeft2(f, _acc, _xs, _ys) {
	  while(true) {
	    var ys = _ys;
	    var xs = _xs;
	    var acc = _acc;
	    if (xs) {
	      if (ys) {
	        _ys = ys[1];
	        _xs = xs[1];
	        _acc = Curry._3(f, xs[0], ys[0], acc);
	        continue ;
	        
	      } else {
	        return acc;
	      }
	    } else {
	      return acc;
	    }
	  };
	}

	function foldRight2(f, acc, xs, ys) {
	  if (xs && ys) {
	    return Curry._3(f, xs[0], ys[0], foldRight2(f, acc, xs[1], ys[1]));
	  } else {
	    return acc;
	  }
	}

	function repeat(count, x) {
	  var _acc = /* [] */0;
	  var _count = count;
	  while(true) {
	    var count$1 = _count;
	    var acc = _acc;
	    if (count$1 <= 0) {
	      return acc;
	    } else {
	      _count = count$1 - 1 | 0;
	      _acc = /* :: */[
	        x,
	        acc
	      ];
	      continue ;
	      
	    }
	  };
	}

	function range(start, stop) {
	  var go = function (acc, start) {
	    if (start >= stop) {
	      return acc;
	    } else {
	      return /* :: */[
	              start,
	              go(acc, start + 1 | 0)
	            ];
	    }
	  };
	  return go(/* [] */0, start);
	}

	function cons(x, xs) {
	  return Pervasives.$at(xs, /* :: */[
	              x,
	              /* [] */0
	            ]);
	}

	var append = Pervasives.$at;

	function flatten$3(xs) {
	  return foldLeft(append, /* [] */0, xs);
	}

	function zip(xs, ys) {
	  if (xs && ys) {
	    return /* :: */[
	            /* tuple */[
	              xs[0],
	              ys[0]
	            ],
	            zip(xs[1], ys[1])
	          ];
	  } else {
	    return /* [] */0;
	  }
	}

	function head(xs) {
	  if (xs) {
	    return /* Some */[xs[0]];
	  } else {
	    return /* None */0;
	  }
	}

	function tail(xs) {
	  if (xs) {
	    return xs[1];
	  } else {
	    return /* [] */0;
	  }
	}

	function nth(_i, _xs) {
	  while(true) {
	    var xs = _xs;
	    var i = _i;
	    if (xs) {
	      if (i <= 0) {
	        return /* Some */[xs[0]];
	      } else {
	        _xs = xs[1];
	        _i = i - 1 | 0;
	        continue ;
	        
	      }
	    } else {
	      return /* None */0;
	    }
	  };
	}

	function take(count, xs) {
	  if (xs && count > 0) {
	    return /* :: */[
	            xs[0],
	            take(count - 1 | 0, xs[1])
	          ];
	  } else {
	    return /* [] */0;
	  }
	}

	function drop(_count, _xs) {
	  while(true) {
	    var xs = _xs;
	    var count = _count;
	    if (xs) {
	      if (count <= 0) {
	        return /* [] */0;
	      } else {
	        _xs = xs[1];
	        _count = count - 1 | 0;
	        continue ;
	        
	      }
	    } else {
	      return /* [] */0;
	    }
	  };
	}

	function takeLast(count, xs) {
	  return drop(List.length(xs) - count | 0, xs);
	}

	function takeUntil(f, xs) {
	  var _acc = /* [] */0;
	  var f$1 = f;
	  var _xs = xs;
	  while(true) {
	    var xs$1 = _xs;
	    var acc = _acc;
	    if (xs$1) {
	      var x = xs$1[0];
	      if (Curry._1(f$1, x)) {
	        return acc;
	      } else {
	        _xs = xs$1[1];
	        _acc = /* :: */[
	          x,
	          acc
	        ];
	        continue ;
	        
	      }
	    } else {
	      return acc;
	    }
	  };
	}

	function takeWhile(f, xs) {
	  return takeUntil((function (a) {
	                return 1 - Curry._1(f, a);
	              }), xs);
	}

	function dropLast(count, xs) {
	  return take(List.length(xs) - count | 0, xs);
	}

	function dropUntil(f, _xs) {
	  while(true) {
	    var xs = _xs;
	    if (xs) {
	      if (Curry._1(f, xs[0])) {
	        return xs;
	      } else {
	        _xs = xs[1];
	        continue ;
	        
	      }
	    } else {
	      return /* [] */0;
	    }
	  };
	}

	function dropWhile(f, xs) {
	  return dropUntil((function (x) {
	                return 1 - Curry._1(f, x);
	              }), xs);
	}

	function filter(f, _xs) {
	  while(true) {
	    var xs = _xs;
	    if (xs) {
	      var xs$1 = xs[1];
	      var x = xs[0];
	      if (Curry._1(f, x)) {
	        return /* :: */[
	                x,
	                filter(f, xs$1)
	              ];
	      } else {
	        _xs = xs$1;
	        continue ;
	        
	      }
	    } else {
	      return /* [] */0;
	    }
	  };
	}

	function map$3(f, xs) {
	  if (xs) {
	    return /* :: */[
	            Curry._1(f, xs[0]),
	            map$3(f, xs[1])
	          ];
	  } else {
	    return /* [] */0;
	  }
	}

	function mapIndexed(f, xs) {
	  var go = function (i, f, xs) {
	    if (xs) {
	      return /* :: */[
	              Curry._2(f, i, xs[0]),
	              go(i + 1 | 0, f, xs[1])
	            ];
	    } else {
	      return /* [] */0;
	    }
	  };
	  return go(0, f, xs);
	}

	function map2$3(f, xs, ys) {
	  if (xs && ys) {
	    return /* :: */[
	            Curry._2(f, xs[0], ys[0]),
	            map2$3(f, xs[1], ys[1])
	          ];
	  } else {
	    return /* [] */0;
	  }
	}

	function flatMap$3(f, xs) {
	  if (xs) {
	    return Pervasives.$at(Curry._1(f, xs[0]), flatMap$3(f, xs[1]));
	  } else {
	    return /* [] */0;
	  }
	}

	function flatMap2(f, xs, ys) {
	  if (xs && ys) {
	    return Pervasives.$at(Curry._2(f, xs[0], ys[0]), flatMap2(f, xs[1], ys[1]));
	  } else {
	    return /* [] */0;
	  }
	}

	function filterMap(f, _xs) {
	  while(true) {
	    var xs = _xs;
	    if (xs) {
	      var xs$1 = xs[1];
	      var match = Curry._1(f, xs[0]);
	      if (match) {
	        return /* :: */[
	                match[0],
	                filterMap(f, xs$1)
	              ];
	      } else {
	        _xs = xs$1;
	        continue ;
	        
	      }
	    } else {
	      return /* [] */0;
	    }
	  };
	}

	function iter(f, _xs) {
	  while(true) {
	    var xs = _xs;
	    if (xs) {
	      Curry._1(f, xs[0]);
	      _xs = xs[1];
	      continue ;
	      
	    } else {
	      return /* () */0;
	    }
	  };
	}

	function iter2(f, _xs, _ys) {
	  while(true) {
	    var ys = _ys;
	    var xs = _xs;
	    if (xs) {
	      if (ys) {
	        Curry._2(f, xs[0], ys[0]);
	        _ys = ys[1];
	        _xs = xs[1];
	        continue ;
	        
	      } else {
	        return /* () */0;
	      }
	    } else {
	      return /* () */0;
	    }
	  };
	}

	function iterIndexed(f, xs) {
	  var _i = 0;
	  var f$1 = f;
	  var _xs = xs;
	  while(true) {
	    var xs$1 = _xs;
	    var i = _i;
	    if (xs$1) {
	      Curry._2(f$1, i, xs$1[0]);
	      _xs = xs$1[1];
	      _i = i + 1 | 0;
	      continue ;
	      
	    } else {
	      return /* () */0;
	    }
	  };
	}

	function find(f, _xs) {
	  while(true) {
	    var xs = _xs;
	    if (xs) {
	      var x = xs[0];
	      if (Curry._1(f, x)) {
	        return /* Some */[x];
	      } else {
	        _xs = xs[1];
	        continue ;
	        
	      }
	    } else {
	      return /* None */0;
	    }
	  };
	}

	function any(f, xs) {
	  return isSome(find(f, xs));
	}

	function all(f, xs) {
	  return any((function (x) {
	                return 1 - Curry._1(f, x);
	              }), xs);
	}

	function contains(y, xs) {
	  return any((function (x) {
	                return Caml_obj.caml_equal(x, y);
	              }), xs);
	}

	function partition(f, xs) {
	  var _param = /* tuple */[
	    /* [] */0,
	    /* [] */0
	  ];
	  var f$1 = f;
	  var _xs = xs;
	  while(true) {
	    var param = _param;
	    var xs$1 = _xs;
	    var l2 = param[1];
	    var l1 = param[0];
	    if (xs$1) {
	      var xs$2 = xs$1[1];
	      var x = xs$1[0];
	      if (Curry._1(f$1, x)) {
	        _xs = xs$2;
	        _param = /* tuple */[
	          /* :: */[
	            x,
	            l1
	          ],
	          l2
	        ];
	        continue ;
	        
	      } else {
	        _xs = xs$2;
	        _param = /* tuple */[
	          l1,
	          /* :: */[
	            x,
	            l2
	          ]
	        ];
	        continue ;
	        
	      }
	    } else {
	      return /* tuple */[
	              l1,
	              l2
	            ];
	    }
	  };
	}

	function split(pairs) {
	  var _param = /* tuple */[
	    /* [] */0,
	    /* [] */0
	  ];
	  var _pairs = pairs;
	  while(true) {
	    var param = _param;
	    var pairs$1 = _pairs;
	    var ys = param[1];
	    var xs = param[0];
	    if (pairs$1) {
	      var match = pairs$1[0];
	      _pairs = pairs$1[1];
	      _param = /* tuple */[
	        /* :: */[
	          match[0],
	          xs
	        ],
	        /* :: */[
	          match[1],
	          ys
	        ]
	      ];
	      continue ;
	      
	    } else {
	      return /* tuple */[
	              xs,
	              ys
	            ];
	    }
	  };
	}

	function fromList(a) {
	  return a;
	}

	function get(key, _dict) {
	  while(true) {
	    var dict = _dict;
	    if (dict) {
	      var match = dict[0];
	      if (Caml_obj.caml_equal(match[0], key)) {
	        return /* Some */[match[1]];
	      } else {
	        _dict = dict[1];
	        continue ;
	        
	      }
	    } else {
	      return /* None */0;
	    }
	  };
	}

	function find$1(f, _dict) {
	  while(true) {
	    var dict = _dict;
	    if (dict) {
	      var v = dict[0][1];
	      if (Curry._1(f, v)) {
	        return /* Some */[v];
	      } else {
	        _dict = dict[1];
	        continue ;
	        
	      }
	    } else {
	      return /* None */0;
	    }
	  };
	}

	function contains$1(key, dict) {
	  return isSome(get(key, dict));
	}

	function set(key, value, dict) {
	  return /* :: */[
	          /* tuple */[
	            key,
	            value
	          ],
	          filter((function (param) {
	                  return Caml_obj.caml_notequal(param[0], key);
	                }), dict)
	        ];
	}

	function setDefault(key, value, dict) {
	  if (contains$1(key, dict)) {
	    return dict;
	  } else {
	    return /* :: */[
	            /* tuple */[
	              key,
	              value
	            ],
	            dict
	          ];
	  }
	}

	function keys(dict) {
	  return map$3((function (param) {
	                return param[0];
	              }), dict);
	}

	function values(dict) {
	  return map$3((function (param) {
	                return param[1];
	              }), dict);
	}

	function iter$1(f) {
	  return (function (param) {
	      return iter((function (param) {
	                    return uncurry(f, param);
	                  }), param);
	    });
	}

	function map$4(f, dict) {
	  return map$3((function (param) {
	                var k = param[0];
	                return /* tuple */[
	                        k,
	                        Curry._2(f, k, param[1])
	                      ];
	              }), dict);
	}

	function mapValues(f, dict) {
	  return map$3((function (param) {
	                return /* tuple */[
	                        param[0],
	                        Curry._1(f, param[1])
	                      ];
	              }), dict);
	}

	function mapKeys(f, dict) {
	  return map$3((function (param) {
	                return /* tuple */[
	                        Curry._1(f, param[0]),
	                        param[1]
	                      ];
	              }), dict);
	}

	function filter$1(f) {
	  return (function (param) {
	      return filter((function (param) {
	                    return uncurry(f, param);
	                  }), param);
	    });
	}

	function foldLeft$1(f, acc, dict) {
	  return foldLeft((function (param, acc) {
	                return Curry._3(f, param[0], param[1], acc);
	              }), acc, dict);
	}

	function foldRight$1(f, acc, dict) {
	  return foldRight((function (param, acc) {
	                return Curry._3(f, param[0], param[1], acc);
	              }), acc, dict);
	}

	var Dict = /* module */[
	  /* empty : [] */0,
	  /* fromList */fromList,
	  /* get */get,
	  /* find */find$1,
	  /* contains */contains$1,
	  /* set */set,
	  /* setDefault */setDefault,
	  /* keys */keys,
	  /* values */values,
	  /* iter */iter$1,
	  /* map */map$4,
	  /* mapValues */mapValues,
	  /* mapKeys */mapKeys,
	  /* filter */filter$1,
	  /* foldLeft */foldLeft$1,
	  /* foldRight */foldRight$1
	];

	function length(prim) {
	  return prim.length;
	}

	function isEmpty$1(s) {
	  return +(s === "");
	}

	function fromChar(param) {
	  return $$String.make(1, param);
	}

	function fromChars(chars) {
	  return foldLeft((function (ch, str) {
	                return str + $$String.make(1, ch);
	              }), "", chars);
	}

	function get$1(index, str) {
	  try {
	    return /* Some */[Caml_string.get(str, index)];
	  }
	  catch (raw_exn){
	    var exn = Js_exn.internalToOCamlException(raw_exn);
	    if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
	      return /* None */0;
	    } else {
	      throw exn;
	    }
	  }
	}

	function cons$1(ch, str) {
	  return $$String.make(1, ch) + str;
	}

	function substring(start, len, str) {
	  try {
	    return $$String.sub(str, start, Pervasives.min(len, str.length - start | 0));
	  }
	  catch (raw_exn){
	    var exn = Js_exn.internalToOCamlException(raw_exn);
	    if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
	      return "";
	    } else {
	      throw exn;
	    }
	  }
	}

	function uncons(str) {
	  var match = get$1(0, str);
	  if (match) {
	    return /* Some */[/* tuple */[
	              match[0],
	              substring(1, str.length, str)
	            ]];
	  } else {
	    return /* None */0;
	  }
	}

	function take$1(i, str) {
	  return substring(0, i, str);
	}

	function drop$1(i, str) {
	  return substring(i, str.length, str);
	}

	function takeLast$1(i, str) {
	  return drop$1(str.length - i | 0, str);
	}

	function dropLast$1(i, str) {
	  return substring(0, str.length - i | 0, str);
	}

	function takeUntil$1(f, str) {
	  var match = uncons(str);
	  if (match) {
	    var match$1 = match[0];
	    var ch = match$1[0];
	    if (Curry._1(f, ch)) {
	      return "";
	    } else {
	      return $$String.make(1, ch) + takeUntil$1(f, match$1[1]);
	    }
	  } else {
	    return "";
	  }
	}

	function takeWhile$1(f, str) {
	  return takeUntil$1((function (x) {
	                return 1 - Curry._1(f, x);
	              }), str);
	}

	function dropUntil$1(f, _str) {
	  while(true) {
	    var str = _str;
	    var match = uncons(str);
	    if (match) {
	      var match$1 = match[0];
	      var str$1 = match$1[1];
	      if (Curry._1(f, match$1[0])) {
	        return str$1;
	      } else {
	        _str = str$1;
	        continue ;
	        
	      }
	    } else {
	      return "";
	    }
	  };
	}

	function dropWhile$1(f, str) {
	  return dropUntil$1((function (x) {
	                return 1 - Curry._1(f, x);
	              }), str);
	}

	function reverse$1(s) {
	  var match = uncons(s);
	  if (match) {
	    var match$1 = match[0];
	    return reverse$1(match$1[1]) + $$String.make(1, match$1[0]);
	  } else {
	    return "";
	  }
	}

	function append$1(x, y) {
	  return x + y;
	}

	function indexOf(ch, str) {
	  try {
	    return /* Some */[$$String.index(str, ch)];
	  }
	  catch (exn){
	    if (exn === Caml_builtin_exceptions.not_found) {
	      return /* None */0;
	    } else {
	      throw exn;
	    }
	  }
	}

	function lastIndexOf(ch, str) {
	  try {
	    return /* Some */[$$String.rindex(str, ch)];
	  }
	  catch (exn){
	    if (exn === Caml_builtin_exceptions.not_found) {
	      return /* None */0;
	    } else {
	      throw exn;
	    }
	  }
	}

	function indexFrom(i, ch, str) {
	  try {
	    return /* Some */[$$String.index_from(str, i, ch)];
	  }
	  catch (exn){
	    if (exn === Caml_builtin_exceptions.not_found) {
	      return /* None */0;
	    } else {
	      throw exn;
	    }
	  }
	}

	function lastIndexFrom(i, ch, str) {
	  try {
	    return /* Some */[$$String.rindex_from(str, i, ch)];
	  }
	  catch (exn){
	    if (exn === Caml_builtin_exceptions.not_found) {
	      return /* None */0;
	    } else {
	      throw exn;
	    }
	  }
	}

	function contains$2(c, s) {
	  return $$String.contains(s, c);
	}

	function pad(_i, _padding, str) {
	  while(true) {
	    var padding = _padding;
	    var i = _i;
	    if (i <= 0) {
	      return str;
	    } else {
	      _padding = padding + (str + padding);
	      _i = i - 1 | 0;
	      continue ;
	      
	    }
	  };
	}

	function leftPad(_i, _padding, str) {
	  while(true) {
	    var padding = _padding;
	    var i = _i;
	    if (i <= 0) {
	      return str;
	    } else {
	      _padding = padding + str;
	      _i = i - 1 | 0;
	      continue ;
	      
	    }
	  };
	}

	function rightPad(_i, _padding, str) {
	  while(true) {
	    var padding = _padding;
	    var i = _i;
	    if (i <= 0) {
	      return str;
	    } else {
	      _padding = str + padding;
	      _i = i - 1 | 0;
	      continue ;
	      
	    }
	  };
	}

	function split$1(separator, str) {
	  var len = separator.length;
	  var go = function (_i, str) {
	    while(true) {
	      var i = _i;
	      var sub = substring(i, len, str);
	      if (sub === separator) {
	        return /* :: */[
	                substring(0, i, str),
	                go(0, drop$1(i + len | 0, str))
	              ];
	      } else if (i === str.length) {
	        return /* :: */[
	                str,
	                /* [] */0
	              ];
	      } else {
	        _i = i + 1 | 0;
	        continue ;
	        
	      }
	    };
	  };
	  return go(0, str);
	}

	function lines(param) {
	  return split$1("\n", param);
	}

	function words(param) {
	  return split$1(" ", param);
	}

	function make(create, fail, success) {
	  return Curry._2(create, fail, success);
	}

	function succeed(a) {
	  return (function (_, param) {
	      return Curry._1(param, a);
	    });
	}

	function fail(x) {
	  return (function (param, _) {
	      return Curry._1(param, x);
	    });
	}

	function fork(fail, success, task) {
	  return Curry._2(task, fail, success);
	}

	function map$5(f, task) {
	  return (function (param, param$1) {
	      return Curry._2(task, param, (function (x) {
	                    return Curry._1(param$1, Curry._1(f, x));
	                  }));
	    });
	}

	function map2$4(f, t1, t2) {
	  return (function (param, param$1) {
	      return Curry._2(t1, param, (function (a1) {
	                    return Curry._2(t2, param, (function (a2) {
	                                  return Curry._1(param$1, Curry._2(f, a1, a2));
	                                }));
	                  }));
	    });
	}

	function map3$3(f, t1, t2, t3) {
	  return (function (param, param$1) {
	      return Curry._2(t1, param, (function (a1) {
	                    return Curry._2(t2, param, (function (a2) {
	                                  return Curry._2(t3, param, (function (a3) {
	                                                return Curry._1(param$1, Curry._3(f, a1, a2, a3));
	                                              }));
	                                }));
	                  }));
	    });
	}

	function flatMap$4(f, task) {
	  return (function (param, param$1) {
	      return Curry._2(task, param, (function (x) {
	                    return Curry._3(f, x, param, param$1);
	                  }));
	    });
	}

	function biMap(mapFail, mapSuccess, task) {
	  return (function (param, param$1) {
	      return Curry._2(task, (function (err) {
	                    return Curry._1(param, Curry._1(mapFail, err));
	                  }), (function (ok) {
	                    return Curry._1(param$1, Curry._1(mapSuccess, ok));
	                  }));
	    });
	}

	function fold(mapFail, mapSuccess, task) {
	  return (function (_, param) {
	      return Curry._2(task, (function (err) {
	                    return Curry._1(param, Curry._1(mapFail, err));
	                  }), (function (ok) {
	                    return Curry._1(param, Curry._1(mapSuccess, ok));
	                  }));
	    });
	}

	function fromLazyPromise(f) {
	  return (function (param, param$1) {
	      Curry._1(f, /* () */0).then(param$1, param);
	      return /* () */0;
	    });
	}

	function fromOption$2(err, opt) {
	  if (opt) {
	    var a = opt[0];
	    return (function (_, param) {
	        return Curry._1(param, a);
	      });
	  } else {
	    return (function (param, _) {
	        return Curry._1(param, err);
	      });
	  }
	}

	function fromResult$2(res) {
	  if (res.tag) {
	    var a = res[0];
	    return (function (_, param) {
	        return Curry._1(param, a);
	      });
	  } else {
	    var x = res[0];
	    return (function (param, _) {
	        return Curry._1(param, x);
	      });
	  }
	}

	var Remote = [
	  ready,
	  error,
	  /* Pending */1,
	  /* NotAsked */0,
	  map$1,
	  map2$1,
	  map3$1,
	  flatten$1,
	  flatMap$1,
	  withDefault$1,
	  fromResult$1,
	  fromOption,
	  isNotAsked,
	  isPending,
	  isFailed,
	  isReady
	];

	var List$1 = [
	  List.length,
	  isEmpty,
	  reverse,
	  List.merge,
	  repeat,
	  range,
	  cons,
	  append,
	  flatten$3,
	  zip,
	  head,
	  tail,
	  nth,
	  take,
	  takeLast,
	  takeWhile,
	  takeUntil,
	  drop,
	  dropLast,
	  dropWhile,
	  dropUntil,
	  filter,
	  map$3,
	  mapIndexed,
	  map2$3,
	  flatMap$3,
	  flatMap2,
	  filterMap,
	  iter,
	  iter2,
	  iterIndexed,
	  foldLeft,
	  foldRight,
	  foldLeft2,
	  foldRight2,
	  find,
	  all,
	  any,
	  contains,
	  partition,
	  split,
	  List.sort
	];

	var $$String$1 = [
	  length,
	  isEmpty$1,
	  fromChar,
	  Pervasives.string_of_int,
	  Pervasives.string_of_float,
	  fromChars,
	  $$String.escaped,
	  reverse$1,
	  $$String.uppercase,
	  $$String.lowercase,
	  $$String.capitalize,
	  $$String.uncapitalize,
	  get$1,
	  substring,
	  $$String.trim,
	  take$1,
	  drop$1,
	  takeLast$1,
	  dropLast$1,
	  takeUntil$1,
	  takeWhile$1,
	  dropUntil$1,
	  dropWhile$1,
	  split$1,
	  words,
	  lines,
	  cons$1,
	  uncons,
	  append$1,
	  $$String.concat,
	  pad,
	  leftPad,
	  rightPad,
	  $$String.iter,
	  $$String.iteri,
	  $$String.map,
	  $$String.mapi,
	  indexOf,
	  lastIndexOf,
	  indexFrom,
	  lastIndexFrom,
	  contains$2
	];

	var Task = [
	  make,
	  succeed,
	  fail,
	  map$5,
	  map2$4,
	  map3$3,
	  biMap,
	  flatMap$4,
	  fold,
	  fromResult$2,
	  fromOption$2,
	  fork,
	  fromLazyPromise
	];

	exports.identity     = identity;
	exports.always       = always;
	exports.$$void       = $$void;
	exports.$great$great = $great$great;
	exports.flip         = flip;
	exports.curry        = curry;
	exports.uncurry      = uncurry;
	exports.tap          = tap;
	exports.Remote       = Remote;
	exports.Result       = Result;
	exports.List         = List$1;
	exports.Dict         = Dict;
	exports.$$String     = $$String$1;
	exports.Task         = Task;
	exports.Option       = Option;
	/* No side effect */


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var Curry                   = __webpack_require__(3);
	var Caml_obj                = __webpack_require__(6);
	var Pervasives              = __webpack_require__(8);
	var Caml_builtin_exceptions = __webpack_require__(5);

	function length(l) {
	  var _len = 0;
	  var _param = l;
	  while(true) {
	    var param = _param;
	    var len = _len;
	    if (param) {
	      _param = param[1];
	      _len = len + 1 | 0;
	      continue ;
	      
	    } else {
	      return len;
	    }
	  };
	}

	function hd(param) {
	  if (param) {
	    return param[0];
	  } else {
	    throw [
	          Caml_builtin_exceptions.failure,
	          "hd"
	        ];
	  }
	}

	function tl(param) {
	  if (param) {
	    return param[1];
	  } else {
	    throw [
	          Caml_builtin_exceptions.failure,
	          "tl"
	        ];
	  }
	}

	function nth(l, n) {
	  if (n < 0) {
	    throw [
	          Caml_builtin_exceptions.invalid_argument,
	          "List.nth"
	        ];
	  } else {
	    var _l = l;
	    var _n = n;
	    while(true) {
	      var n$1 = _n;
	      var l$1 = _l;
	      if (l$1) {
	        if (n$1) {
	          _n = n$1 - 1 | 0;
	          _l = l$1[1];
	          continue ;
	          
	        } else {
	          return l$1[0];
	        }
	      } else {
	        throw [
	              Caml_builtin_exceptions.failure,
	              "nth"
	            ];
	      }
	    };
	  }
	}

	function rev_append(_l1, _l2) {
	  while(true) {
	    var l2 = _l2;
	    var l1 = _l1;
	    if (l1) {
	      _l2 = /* :: */[
	        l1[0],
	        l2
	      ];
	      _l1 = l1[1];
	      continue ;
	      
	    } else {
	      return l2;
	    }
	  };
	}

	function rev(l) {
	  return rev_append(l, /* [] */0);
	}

	function flatten(param) {
	  if (param) {
	    return Pervasives.$at(param[0], flatten(param[1]));
	  } else {
	    return /* [] */0;
	  }
	}

	function map(f, param) {
	  if (param) {
	    var r = Curry._1(f, param[0]);
	    return /* :: */[
	            r,
	            map(f, param[1])
	          ];
	  } else {
	    return /* [] */0;
	  }
	}

	function mapi(i, f, param) {
	  if (param) {
	    var r = Curry._2(f, i, param[0]);
	    return /* :: */[
	            r,
	            mapi(i + 1 | 0, f, param[1])
	          ];
	  } else {
	    return /* [] */0;
	  }
	}

	function mapi$1(f, l) {
	  return mapi(0, f, l);
	}

	function rev_map(f, l) {
	  var _accu = /* [] */0;
	  var _param = l;
	  while(true) {
	    var param = _param;
	    var accu = _accu;
	    if (param) {
	      _param = param[1];
	      _accu = /* :: */[
	        Curry._1(f, param[0]),
	        accu
	      ];
	      continue ;
	      
	    } else {
	      return accu;
	    }
	  };
	}

	function iter(f, _param) {
	  while(true) {
	    var param = _param;
	    if (param) {
	      Curry._1(f, param[0]);
	      _param = param[1];
	      continue ;
	      
	    } else {
	      return /* () */0;
	    }
	  };
	}

	function iteri(f, l) {
	  var _i = 0;
	  var f$1 = f;
	  var _param = l;
	  while(true) {
	    var param = _param;
	    var i = _i;
	    if (param) {
	      Curry._2(f$1, i, param[0]);
	      _param = param[1];
	      _i = i + 1 | 0;
	      continue ;
	      
	    } else {
	      return /* () */0;
	    }
	  };
	}

	function fold_left(f, _accu, _l) {
	  while(true) {
	    var l = _l;
	    var accu = _accu;
	    if (l) {
	      _l = l[1];
	      _accu = Curry._2(f, accu, l[0]);
	      continue ;
	      
	    } else {
	      return accu;
	    }
	  };
	}

	function fold_right(f, l, accu) {
	  if (l) {
	    return Curry._2(f, l[0], fold_right(f, l[1], accu));
	  } else {
	    return accu;
	  }
	}

	function map2(f, l1, l2) {
	  if (l1) {
	    if (l2) {
	      var r = Curry._2(f, l1[0], l2[0]);
	      return /* :: */[
	              r,
	              map2(f, l1[1], l2[1])
	            ];
	    } else {
	      throw [
	            Caml_builtin_exceptions.invalid_argument,
	            "List.map2"
	          ];
	    }
	  } else if (l2) {
	    throw [
	          Caml_builtin_exceptions.invalid_argument,
	          "List.map2"
	        ];
	  } else {
	    return /* [] */0;
	  }
	}

	function rev_map2(f, l1, l2) {
	  var _accu = /* [] */0;
	  var _l1 = l1;
	  var _l2 = l2;
	  while(true) {
	    var l2$1 = _l2;
	    var l1$1 = _l1;
	    var accu = _accu;
	    if (l1$1) {
	      if (l2$1) {
	        _l2 = l2$1[1];
	        _l1 = l1$1[1];
	        _accu = /* :: */[
	          Curry._2(f, l1$1[0], l2$1[0]),
	          accu
	        ];
	        continue ;
	        
	      } else {
	        throw [
	              Caml_builtin_exceptions.invalid_argument,
	              "List.rev_map2"
	            ];
	      }
	    } else if (l2$1) {
	      throw [
	            Caml_builtin_exceptions.invalid_argument,
	            "List.rev_map2"
	          ];
	    } else {
	      return accu;
	    }
	  };
	}

	function iter2(f, _l1, _l2) {
	  while(true) {
	    var l2 = _l2;
	    var l1 = _l1;
	    if (l1) {
	      if (l2) {
	        Curry._2(f, l1[0], l2[0]);
	        _l2 = l2[1];
	        _l1 = l1[1];
	        continue ;
	        
	      } else {
	        throw [
	              Caml_builtin_exceptions.invalid_argument,
	              "List.iter2"
	            ];
	      }
	    } else if (l2) {
	      throw [
	            Caml_builtin_exceptions.invalid_argument,
	            "List.iter2"
	          ];
	    } else {
	      return /* () */0;
	    }
	  };
	}

	function fold_left2(f, _accu, _l1, _l2) {
	  while(true) {
	    var l2 = _l2;
	    var l1 = _l1;
	    var accu = _accu;
	    if (l1) {
	      if (l2) {
	        _l2 = l2[1];
	        _l1 = l1[1];
	        _accu = Curry._3(f, accu, l1[0], l2[0]);
	        continue ;
	        
	      } else {
	        throw [
	              Caml_builtin_exceptions.invalid_argument,
	              "List.fold_left2"
	            ];
	      }
	    } else if (l2) {
	      throw [
	            Caml_builtin_exceptions.invalid_argument,
	            "List.fold_left2"
	          ];
	    } else {
	      return accu;
	    }
	  };
	}

	function fold_right2(f, l1, l2, accu) {
	  if (l1) {
	    if (l2) {
	      return Curry._3(f, l1[0], l2[0], fold_right2(f, l1[1], l2[1], accu));
	    } else {
	      throw [
	            Caml_builtin_exceptions.invalid_argument,
	            "List.fold_right2"
	          ];
	    }
	  } else if (l2) {
	    throw [
	          Caml_builtin_exceptions.invalid_argument,
	          "List.fold_right2"
	        ];
	  } else {
	    return accu;
	  }
	}

	function for_all(p, _param) {
	  while(true) {
	    var param = _param;
	    if (param) {
	      if (Curry._1(p, param[0])) {
	        _param = param[1];
	        continue ;
	        
	      } else {
	        return /* false */0;
	      }
	    } else {
	      return /* true */1;
	    }
	  };
	}

	function exists(p, _param) {
	  while(true) {
	    var param = _param;
	    if (param) {
	      if (Curry._1(p, param[0])) {
	        return /* true */1;
	      } else {
	        _param = param[1];
	        continue ;
	        
	      }
	    } else {
	      return /* false */0;
	    }
	  };
	}

	function for_all2(p, _l1, _l2) {
	  while(true) {
	    var l2 = _l2;
	    var l1 = _l1;
	    if (l1) {
	      if (l2) {
	        if (Curry._2(p, l1[0], l2[0])) {
	          _l2 = l2[1];
	          _l1 = l1[1];
	          continue ;
	          
	        } else {
	          return /* false */0;
	        }
	      } else {
	        throw [
	              Caml_builtin_exceptions.invalid_argument,
	              "List.for_all2"
	            ];
	      }
	    } else if (l2) {
	      throw [
	            Caml_builtin_exceptions.invalid_argument,
	            "List.for_all2"
	          ];
	    } else {
	      return /* true */1;
	    }
	  };
	}

	function exists2(p, _l1, _l2) {
	  while(true) {
	    var l2 = _l2;
	    var l1 = _l1;
	    if (l1) {
	      if (l2) {
	        if (Curry._2(p, l1[0], l2[0])) {
	          return /* true */1;
	        } else {
	          _l2 = l2[1];
	          _l1 = l1[1];
	          continue ;
	          
	        }
	      } else {
	        throw [
	              Caml_builtin_exceptions.invalid_argument,
	              "List.exists2"
	            ];
	      }
	    } else if (l2) {
	      throw [
	            Caml_builtin_exceptions.invalid_argument,
	            "List.exists2"
	          ];
	    } else {
	      return /* false */0;
	    }
	  };
	}

	function mem(x, _param) {
	  while(true) {
	    var param = _param;
	    if (param) {
	      if (Caml_obj.caml_compare(param[0], x)) {
	        _param = param[1];
	        continue ;
	        
	      } else {
	        return /* true */1;
	      }
	    } else {
	      return /* false */0;
	    }
	  };
	}

	function memq(x, _param) {
	  while(true) {
	    var param = _param;
	    if (param) {
	      if (param[0] === x) {
	        return /* true */1;
	      } else {
	        _param = param[1];
	        continue ;
	        
	      }
	    } else {
	      return /* false */0;
	    }
	  };
	}

	function assoc(x, _param) {
	  while(true) {
	    var param = _param;
	    if (param) {
	      var match = param[0];
	      if (Caml_obj.caml_compare(match[0], x)) {
	        _param = param[1];
	        continue ;
	        
	      } else {
	        return match[1];
	      }
	    } else {
	      throw Caml_builtin_exceptions.not_found;
	    }
	  };
	}

	function assq(x, _param) {
	  while(true) {
	    var param = _param;
	    if (param) {
	      var match = param[0];
	      if (match[0] === x) {
	        return match[1];
	      } else {
	        _param = param[1];
	        continue ;
	        
	      }
	    } else {
	      throw Caml_builtin_exceptions.not_found;
	    }
	  };
	}

	function mem_assoc(x, _param) {
	  while(true) {
	    var param = _param;
	    if (param) {
	      if (Caml_obj.caml_compare(param[0][0], x)) {
	        _param = param[1];
	        continue ;
	        
	      } else {
	        return /* true */1;
	      }
	    } else {
	      return /* false */0;
	    }
	  };
	}

	function mem_assq(x, _param) {
	  while(true) {
	    var param = _param;
	    if (param) {
	      if (param[0][0] === x) {
	        return /* true */1;
	      } else {
	        _param = param[1];
	        continue ;
	        
	      }
	    } else {
	      return /* false */0;
	    }
	  };
	}

	function remove_assoc(x, param) {
	  if (param) {
	    var l = param[1];
	    var pair = param[0];
	    if (Caml_obj.caml_compare(pair[0], x)) {
	      return /* :: */[
	              pair,
	              remove_assoc(x, l)
	            ];
	    } else {
	      return l;
	    }
	  } else {
	    return /* [] */0;
	  }
	}

	function remove_assq(x, param) {
	  if (param) {
	    var l = param[1];
	    var pair = param[0];
	    if (pair[0] === x) {
	      return l;
	    } else {
	      return /* :: */[
	              pair,
	              remove_assq(x, l)
	            ];
	    }
	  } else {
	    return /* [] */0;
	  }
	}

	function find(p, _param) {
	  while(true) {
	    var param = _param;
	    if (param) {
	      var x = param[0];
	      if (Curry._1(p, x)) {
	        return x;
	      } else {
	        _param = param[1];
	        continue ;
	        
	      }
	    } else {
	      throw Caml_builtin_exceptions.not_found;
	    }
	  };
	}

	function find_all(p) {
	  return (function (param) {
	      var _accu = /* [] */0;
	      var _param = param;
	      while(true) {
	        var param$1 = _param;
	        var accu = _accu;
	        if (param$1) {
	          var l = param$1[1];
	          var x = param$1[0];
	          if (Curry._1(p, x)) {
	            _param = l;
	            _accu = /* :: */[
	              x,
	              accu
	            ];
	            continue ;
	            
	          } else {
	            _param = l;
	            continue ;
	            
	          }
	        } else {
	          return rev_append(accu, /* [] */0);
	        }
	      };
	    });
	}

	function partition(p, l) {
	  var _yes = /* [] */0;
	  var _no = /* [] */0;
	  var _param = l;
	  while(true) {
	    var param = _param;
	    var no = _no;
	    var yes = _yes;
	    if (param) {
	      var l$1 = param[1];
	      var x = param[0];
	      if (Curry._1(p, x)) {
	        _param = l$1;
	        _yes = /* :: */[
	          x,
	          yes
	        ];
	        continue ;
	        
	      } else {
	        _param = l$1;
	        _no = /* :: */[
	          x,
	          no
	        ];
	        continue ;
	        
	      }
	    } else {
	      return /* tuple */[
	              rev_append(yes, /* [] */0),
	              rev_append(no, /* [] */0)
	            ];
	    }
	  };
	}

	function split(param) {
	  if (param) {
	    var match = param[0];
	    var match$1 = split(param[1]);
	    return /* tuple */[
	            /* :: */[
	              match[0],
	              match$1[0]
	            ],
	            /* :: */[
	              match[1],
	              match$1[1]
	            ]
	          ];
	  } else {
	    return /* tuple */[
	            /* [] */0,
	            /* [] */0
	          ];
	  }
	}

	function combine(l1, l2) {
	  if (l1) {
	    if (l2) {
	      return /* :: */[
	              /* tuple */[
	                l1[0],
	                l2[0]
	              ],
	              combine(l1[1], l2[1])
	            ];
	    } else {
	      throw [
	            Caml_builtin_exceptions.invalid_argument,
	            "List.combine"
	          ];
	    }
	  } else if (l2) {
	    throw [
	          Caml_builtin_exceptions.invalid_argument,
	          "List.combine"
	        ];
	  } else {
	    return /* [] */0;
	  }
	}

	function merge(cmp, l1, l2) {
	  if (l1) {
	    if (l2) {
	      var h2 = l2[0];
	      var h1 = l1[0];
	      if (Curry._2(cmp, h1, h2) <= 0) {
	        return /* :: */[
	                h1,
	                merge(cmp, l1[1], l2)
	              ];
	      } else {
	        return /* :: */[
	                h2,
	                merge(cmp, l1, l2[1])
	              ];
	      }
	    } else {
	      return l1;
	    }
	  } else {
	    return l2;
	  }
	}

	function chop(_k, _l) {
	  while(true) {
	    var l = _l;
	    var k = _k;
	    if (k) {
	      if (l) {
	        _l = l[1];
	        _k = k - 1 | 0;
	        continue ;
	        
	      } else {
	        throw [
	              Caml_builtin_exceptions.assert_failure,
	              [
	                "list.ml",
	                223,
	                11
	              ]
	            ];
	      }
	    } else {
	      return l;
	    }
	  };
	}

	function stable_sort(cmp, l) {
	  var sort = function (n, l) {
	    var exit = 0;
	    if (n !== 2) {
	      if (n !== 3) {
	        exit = 1;
	      } else if (l) {
	        var match = l[1];
	        if (match) {
	          var match$1 = match[1];
	          if (match$1) {
	            var x3 = match$1[0];
	            var x2 = match[0];
	            var x1 = l[0];
	            if (Curry._2(cmp, x1, x2) <= 0) {
	              if (Curry._2(cmp, x2, x3) <= 0) {
	                return /* :: */[
	                        x1,
	                        /* :: */[
	                          x2,
	                          /* :: */[
	                            x3,
	                            /* [] */0
	                          ]
	                        ]
	                      ];
	              } else if (Curry._2(cmp, x1, x3) <= 0) {
	                return /* :: */[
	                        x1,
	                        /* :: */[
	                          x3,
	                          /* :: */[
	                            x2,
	                            /* [] */0
	                          ]
	                        ]
	                      ];
	              } else {
	                return /* :: */[
	                        x3,
	                        /* :: */[
	                          x1,
	                          /* :: */[
	                            x2,
	                            /* [] */0
	                          ]
	                        ]
	                      ];
	              }
	            } else if (Curry._2(cmp, x1, x3) <= 0) {
	              return /* :: */[
	                      x2,
	                      /* :: */[
	                        x1,
	                        /* :: */[
	                          x3,
	                          /* [] */0
	                        ]
	                      ]
	                    ];
	            } else if (Curry._2(cmp, x2, x3) <= 0) {
	              return /* :: */[
	                      x2,
	                      /* :: */[
	                        x3,
	                        /* :: */[
	                          x1,
	                          /* [] */0
	                        ]
	                      ]
	                    ];
	            } else {
	              return /* :: */[
	                      x3,
	                      /* :: */[
	                        x2,
	                        /* :: */[
	                          x1,
	                          /* [] */0
	                        ]
	                      ]
	                    ];
	            }
	          } else {
	            exit = 1;
	          }
	        } else {
	          exit = 1;
	        }
	      } else {
	        exit = 1;
	      }
	    } else if (l) {
	      var match$2 = l[1];
	      if (match$2) {
	        var x2$1 = match$2[0];
	        var x1$1 = l[0];
	        if (Curry._2(cmp, x1$1, x2$1) <= 0) {
	          return /* :: */[
	                  x1$1,
	                  /* :: */[
	                    x2$1,
	                    /* [] */0
	                  ]
	                ];
	        } else {
	          return /* :: */[
	                  x2$1,
	                  /* :: */[
	                    x1$1,
	                    /* [] */0
	                  ]
	                ];
	        }
	      } else {
	        exit = 1;
	      }
	    } else {
	      exit = 1;
	    }
	    if (exit === 1) {
	      var n1 = (n >> 1);
	      var n2 = n - n1 | 0;
	      var l2 = chop(n1, l);
	      var s1 = rev_sort(n1, l);
	      var s2 = rev_sort(n2, l2);
	      var _l1 = s1;
	      var _l2 = s2;
	      var _accu = /* [] */0;
	      while(true) {
	        var accu = _accu;
	        var l2$1 = _l2;
	        var l1 = _l1;
	        if (l1) {
	          if (l2$1) {
	            var h2 = l2$1[0];
	            var h1 = l1[0];
	            if (Curry._2(cmp, h1, h2) > 0) {
	              _accu = /* :: */[
	                h1,
	                accu
	              ];
	              _l1 = l1[1];
	              continue ;
	              
	            } else {
	              _accu = /* :: */[
	                h2,
	                accu
	              ];
	              _l2 = l2$1[1];
	              continue ;
	              
	            }
	          } else {
	            return rev_append(l1, accu);
	          }
	        } else {
	          return rev_append(l2$1, accu);
	        }
	      };
	    }
	    
	  };
	  var rev_sort = function (n, l) {
	    var exit = 0;
	    if (n !== 2) {
	      if (n !== 3) {
	        exit = 1;
	      } else if (l) {
	        var match = l[1];
	        if (match) {
	          var match$1 = match[1];
	          if (match$1) {
	            var x3 = match$1[0];
	            var x2 = match[0];
	            var x1 = l[0];
	            if (Curry._2(cmp, x1, x2) > 0) {
	              if (Curry._2(cmp, x2, x3) > 0) {
	                return /* :: */[
	                        x1,
	                        /* :: */[
	                          x2,
	                          /* :: */[
	                            x3,
	                            /* [] */0
	                          ]
	                        ]
	                      ];
	              } else if (Curry._2(cmp, x1, x3) > 0) {
	                return /* :: */[
	                        x1,
	                        /* :: */[
	                          x3,
	                          /* :: */[
	                            x2,
	                            /* [] */0
	                          ]
	                        ]
	                      ];
	              } else {
	                return /* :: */[
	                        x3,
	                        /* :: */[
	                          x1,
	                          /* :: */[
	                            x2,
	                            /* [] */0
	                          ]
	                        ]
	                      ];
	              }
	            } else if (Curry._2(cmp, x1, x3) > 0) {
	              return /* :: */[
	                      x2,
	                      /* :: */[
	                        x1,
	                        /* :: */[
	                          x3,
	                          /* [] */0
	                        ]
	                      ]
	                    ];
	            } else if (Curry._2(cmp, x2, x3) > 0) {
	              return /* :: */[
	                      x2,
	                      /* :: */[
	                        x3,
	                        /* :: */[
	                          x1,
	                          /* [] */0
	                        ]
	                      ]
	                    ];
	            } else {
	              return /* :: */[
	                      x3,
	                      /* :: */[
	                        x2,
	                        /* :: */[
	                          x1,
	                          /* [] */0
	                        ]
	                      ]
	                    ];
	            }
	          } else {
	            exit = 1;
	          }
	        } else {
	          exit = 1;
	        }
	      } else {
	        exit = 1;
	      }
	    } else if (l) {
	      var match$2 = l[1];
	      if (match$2) {
	        var x2$1 = match$2[0];
	        var x1$1 = l[0];
	        if (Curry._2(cmp, x1$1, x2$1) > 0) {
	          return /* :: */[
	                  x1$1,
	                  /* :: */[
	                    x2$1,
	                    /* [] */0
	                  ]
	                ];
	        } else {
	          return /* :: */[
	                  x2$1,
	                  /* :: */[
	                    x1$1,
	                    /* [] */0
	                  ]
	                ];
	        }
	      } else {
	        exit = 1;
	      }
	    } else {
	      exit = 1;
	    }
	    if (exit === 1) {
	      var n1 = (n >> 1);
	      var n2 = n - n1 | 0;
	      var l2 = chop(n1, l);
	      var s1 = sort(n1, l);
	      var s2 = sort(n2, l2);
	      var _l1 = s1;
	      var _l2 = s2;
	      var _accu = /* [] */0;
	      while(true) {
	        var accu = _accu;
	        var l2$1 = _l2;
	        var l1 = _l1;
	        if (l1) {
	          if (l2$1) {
	            var h2 = l2$1[0];
	            var h1 = l1[0];
	            if (Curry._2(cmp, h1, h2) <= 0) {
	              _accu = /* :: */[
	                h1,
	                accu
	              ];
	              _l1 = l1[1];
	              continue ;
	              
	            } else {
	              _accu = /* :: */[
	                h2,
	                accu
	              ];
	              _l2 = l2$1[1];
	              continue ;
	              
	            }
	          } else {
	            return rev_append(l1, accu);
	          }
	        } else {
	          return rev_append(l2$1, accu);
	        }
	      };
	    }
	    
	  };
	  var len = length(l);
	  if (len < 2) {
	    return l;
	  } else {
	    return sort(len, l);
	  }
	}

	function sort_uniq(cmp, l) {
	  var sort = function (n, l) {
	    var exit = 0;
	    if (n !== 2) {
	      if (n !== 3) {
	        exit = 1;
	      } else if (l) {
	        var match = l[1];
	        if (match) {
	          var match$1 = match[1];
	          if (match$1) {
	            var x3 = match$1[0];
	            var x2 = match[0];
	            var x1 = l[0];
	            var c = Curry._2(cmp, x1, x2);
	            if (c) {
	              if (c < 0) {
	                var c$1 = Curry._2(cmp, x2, x3);
	                if (c$1) {
	                  if (c$1 < 0) {
	                    return /* :: */[
	                            x1,
	                            /* :: */[
	                              x2,
	                              /* :: */[
	                                x3,
	                                /* [] */0
	                              ]
	                            ]
	                          ];
	                  } else {
	                    var c$2 = Curry._2(cmp, x1, x3);
	                    if (c$2) {
	                      if (c$2 < 0) {
	                        return /* :: */[
	                                x1,
	                                /* :: */[
	                                  x3,
	                                  /* :: */[
	                                    x2,
	                                    /* [] */0
	                                  ]
	                                ]
	                              ];
	                      } else {
	                        return /* :: */[
	                                x3,
	                                /* :: */[
	                                  x1,
	                                  /* :: */[
	                                    x2,
	                                    /* [] */0
	                                  ]
	                                ]
	                              ];
	                      }
	                    } else {
	                      return /* :: */[
	                              x1,
	                              /* :: */[
	                                x2,
	                                /* [] */0
	                              ]
	                            ];
	                    }
	                  }
	                } else {
	                  return /* :: */[
	                          x1,
	                          /* :: */[
	                            x2,
	                            /* [] */0
	                          ]
	                        ];
	                }
	              } else {
	                var c$3 = Curry._2(cmp, x1, x3);
	                if (c$3) {
	                  if (c$3 < 0) {
	                    return /* :: */[
	                            x2,
	                            /* :: */[
	                              x1,
	                              /* :: */[
	                                x3,
	                                /* [] */0
	                              ]
	                            ]
	                          ];
	                  } else {
	                    var c$4 = Curry._2(cmp, x2, x3);
	                    if (c$4) {
	                      if (c$4 < 0) {
	                        return /* :: */[
	                                x2,
	                                /* :: */[
	                                  x3,
	                                  /* :: */[
	                                    x1,
	                                    /* [] */0
	                                  ]
	                                ]
	                              ];
	                      } else {
	                        return /* :: */[
	                                x3,
	                                /* :: */[
	                                  x2,
	                                  /* :: */[
	                                    x1,
	                                    /* [] */0
	                                  ]
	                                ]
	                              ];
	                      }
	                    } else {
	                      return /* :: */[
	                              x2,
	                              /* :: */[
	                                x1,
	                                /* [] */0
	                              ]
	                            ];
	                    }
	                  }
	                } else {
	                  return /* :: */[
	                          x2,
	                          /* :: */[
	                            x1,
	                            /* [] */0
	                          ]
	                        ];
	                }
	              }
	            } else {
	              var c$5 = Curry._2(cmp, x2, x3);
	              if (c$5) {
	                if (c$5 < 0) {
	                  return /* :: */[
	                          x2,
	                          /* :: */[
	                            x3,
	                            /* [] */0
	                          ]
	                        ];
	                } else {
	                  return /* :: */[
	                          x3,
	                          /* :: */[
	                            x2,
	                            /* [] */0
	                          ]
	                        ];
	                }
	              } else {
	                return /* :: */[
	                        x2,
	                        /* [] */0
	                      ];
	              }
	            }
	          } else {
	            exit = 1;
	          }
	        } else {
	          exit = 1;
	        }
	      } else {
	        exit = 1;
	      }
	    } else if (l) {
	      var match$2 = l[1];
	      if (match$2) {
	        var x2$1 = match$2[0];
	        var x1$1 = l[0];
	        var c$6 = Curry._2(cmp, x1$1, x2$1);
	        if (c$6) {
	          if (c$6 < 0) {
	            return /* :: */[
	                    x1$1,
	                    /* :: */[
	                      x2$1,
	                      /* [] */0
	                    ]
	                  ];
	          } else {
	            return /* :: */[
	                    x2$1,
	                    /* :: */[
	                      x1$1,
	                      /* [] */0
	                    ]
	                  ];
	          }
	        } else {
	          return /* :: */[
	                  x1$1,
	                  /* [] */0
	                ];
	        }
	      } else {
	        exit = 1;
	      }
	    } else {
	      exit = 1;
	    }
	    if (exit === 1) {
	      var n1 = (n >> 1);
	      var n2 = n - n1 | 0;
	      var l2 = chop(n1, l);
	      var s1 = rev_sort(n1, l);
	      var s2 = rev_sort(n2, l2);
	      var _l1 = s1;
	      var _l2 = s2;
	      var _accu = /* [] */0;
	      while(true) {
	        var accu = _accu;
	        var l2$1 = _l2;
	        var l1 = _l1;
	        if (l1) {
	          if (l2$1) {
	            var t2 = l2$1[1];
	            var h2 = l2$1[0];
	            var t1 = l1[1];
	            var h1 = l1[0];
	            var c$7 = Curry._2(cmp, h1, h2);
	            if (c$7) {
	              if (c$7 > 0) {
	                _accu = /* :: */[
	                  h1,
	                  accu
	                ];
	                _l1 = t1;
	                continue ;
	                
	              } else {
	                _accu = /* :: */[
	                  h2,
	                  accu
	                ];
	                _l2 = t2;
	                continue ;
	                
	              }
	            } else {
	              _accu = /* :: */[
	                h1,
	                accu
	              ];
	              _l2 = t2;
	              _l1 = t1;
	              continue ;
	              
	            }
	          } else {
	            return rev_append(l1, accu);
	          }
	        } else {
	          return rev_append(l2$1, accu);
	        }
	      };
	    }
	    
	  };
	  var rev_sort = function (n, l) {
	    var exit = 0;
	    if (n !== 2) {
	      if (n !== 3) {
	        exit = 1;
	      } else if (l) {
	        var match = l[1];
	        if (match) {
	          var match$1 = match[1];
	          if (match$1) {
	            var x3 = match$1[0];
	            var x2 = match[0];
	            var x1 = l[0];
	            var c = Curry._2(cmp, x1, x2);
	            if (c) {
	              if (c > 0) {
	                var c$1 = Curry._2(cmp, x2, x3);
	                if (c$1) {
	                  if (c$1 > 0) {
	                    return /* :: */[
	                            x1,
	                            /* :: */[
	                              x2,
	                              /* :: */[
	                                x3,
	                                /* [] */0
	                              ]
	                            ]
	                          ];
	                  } else {
	                    var c$2 = Curry._2(cmp, x1, x3);
	                    if (c$2) {
	                      if (c$2 > 0) {
	                        return /* :: */[
	                                x1,
	                                /* :: */[
	                                  x3,
	                                  /* :: */[
	                                    x2,
	                                    /* [] */0
	                                  ]
	                                ]
	                              ];
	                      } else {
	                        return /* :: */[
	                                x3,
	                                /* :: */[
	                                  x1,
	                                  /* :: */[
	                                    x2,
	                                    /* [] */0
	                                  ]
	                                ]
	                              ];
	                      }
	                    } else {
	                      return /* :: */[
	                              x1,
	                              /* :: */[
	                                x2,
	                                /* [] */0
	                              ]
	                            ];
	                    }
	                  }
	                } else {
	                  return /* :: */[
	                          x1,
	                          /* :: */[
	                            x2,
	                            /* [] */0
	                          ]
	                        ];
	                }
	              } else {
	                var c$3 = Curry._2(cmp, x1, x3);
	                if (c$3) {
	                  if (c$3 > 0) {
	                    return /* :: */[
	                            x2,
	                            /* :: */[
	                              x1,
	                              /* :: */[
	                                x3,
	                                /* [] */0
	                              ]
	                            ]
	                          ];
	                  } else {
	                    var c$4 = Curry._2(cmp, x2, x3);
	                    if (c$4) {
	                      if (c$4 > 0) {
	                        return /* :: */[
	                                x2,
	                                /* :: */[
	                                  x3,
	                                  /* :: */[
	                                    x1,
	                                    /* [] */0
	                                  ]
	                                ]
	                              ];
	                      } else {
	                        return /* :: */[
	                                x3,
	                                /* :: */[
	                                  x2,
	                                  /* :: */[
	                                    x1,
	                                    /* [] */0
	                                  ]
	                                ]
	                              ];
	                      }
	                    } else {
	                      return /* :: */[
	                              x2,
	                              /* :: */[
	                                x1,
	                                /* [] */0
	                              ]
	                            ];
	                    }
	                  }
	                } else {
	                  return /* :: */[
	                          x2,
	                          /* :: */[
	                            x1,
	                            /* [] */0
	                          ]
	                        ];
	                }
	              }
	            } else {
	              var c$5 = Curry._2(cmp, x2, x3);
	              if (c$5) {
	                if (c$5 > 0) {
	                  return /* :: */[
	                          x2,
	                          /* :: */[
	                            x3,
	                            /* [] */0
	                          ]
	                        ];
	                } else {
	                  return /* :: */[
	                          x3,
	                          /* :: */[
	                            x2,
	                            /* [] */0
	                          ]
	                        ];
	                }
	              } else {
	                return /* :: */[
	                        x2,
	                        /* [] */0
	                      ];
	              }
	            }
	          } else {
	            exit = 1;
	          }
	        } else {
	          exit = 1;
	        }
	      } else {
	        exit = 1;
	      }
	    } else if (l) {
	      var match$2 = l[1];
	      if (match$2) {
	        var x2$1 = match$2[0];
	        var x1$1 = l[0];
	        var c$6 = Curry._2(cmp, x1$1, x2$1);
	        if (c$6) {
	          if (c$6 > 0) {
	            return /* :: */[
	                    x1$1,
	                    /* :: */[
	                      x2$1,
	                      /* [] */0
	                    ]
	                  ];
	          } else {
	            return /* :: */[
	                    x2$1,
	                    /* :: */[
	                      x1$1,
	                      /* [] */0
	                    ]
	                  ];
	          }
	        } else {
	          return /* :: */[
	                  x1$1,
	                  /* [] */0
	                ];
	        }
	      } else {
	        exit = 1;
	      }
	    } else {
	      exit = 1;
	    }
	    if (exit === 1) {
	      var n1 = (n >> 1);
	      var n2 = n - n1 | 0;
	      var l2 = chop(n1, l);
	      var s1 = sort(n1, l);
	      var s2 = sort(n2, l2);
	      var _l1 = s1;
	      var _l2 = s2;
	      var _accu = /* [] */0;
	      while(true) {
	        var accu = _accu;
	        var l2$1 = _l2;
	        var l1 = _l1;
	        if (l1) {
	          if (l2$1) {
	            var t2 = l2$1[1];
	            var h2 = l2$1[0];
	            var t1 = l1[1];
	            var h1 = l1[0];
	            var c$7 = Curry._2(cmp, h1, h2);
	            if (c$7) {
	              if (c$7 < 0) {
	                _accu = /* :: */[
	                  h1,
	                  accu
	                ];
	                _l1 = t1;
	                continue ;
	                
	              } else {
	                _accu = /* :: */[
	                  h2,
	                  accu
	                ];
	                _l2 = t2;
	                continue ;
	                
	              }
	            } else {
	              _accu = /* :: */[
	                h1,
	                accu
	              ];
	              _l2 = t2;
	              _l1 = t1;
	              continue ;
	              
	            }
	          } else {
	            return rev_append(l1, accu);
	          }
	        } else {
	          return rev_append(l2$1, accu);
	        }
	      };
	    }
	    
	  };
	  var len = length(l);
	  if (len < 2) {
	    return l;
	  } else {
	    return sort(len, l);
	  }
	}

	var append = Pervasives.$at;

	var concat = flatten;

	var filter = find_all;

	var sort = stable_sort;

	var fast_sort = stable_sort;

	exports.length       = length;
	exports.hd           = hd;
	exports.tl           = tl;
	exports.nth          = nth;
	exports.rev          = rev;
	exports.append       = append;
	exports.rev_append   = rev_append;
	exports.concat       = concat;
	exports.flatten      = flatten;
	exports.iter         = iter;
	exports.iteri        = iteri;
	exports.map          = map;
	exports.mapi         = mapi$1;
	exports.rev_map      = rev_map;
	exports.fold_left    = fold_left;
	exports.fold_right   = fold_right;
	exports.iter2        = iter2;
	exports.map2         = map2;
	exports.rev_map2     = rev_map2;
	exports.fold_left2   = fold_left2;
	exports.fold_right2  = fold_right2;
	exports.for_all      = for_all;
	exports.exists       = exists;
	exports.for_all2     = for_all2;
	exports.exists2      = exists2;
	exports.mem          = mem;
	exports.memq         = memq;
	exports.find         = find;
	exports.filter       = filter;
	exports.find_all     = find_all;
	exports.partition    = partition;
	exports.assoc        = assoc;
	exports.assq         = assq;
	exports.mem_assoc    = mem_assoc;
	exports.mem_assq     = mem_assq;
	exports.remove_assoc = remove_assoc;
	exports.remove_assq  = remove_assq;
	exports.split        = split;
	exports.combine      = combine;
	exports.sort         = sort;
	exports.stable_sort  = stable_sort;
	exports.fast_sort    = fast_sort;
	exports.sort_uniq    = sort_uniq;
	exports.merge        = merge;
	/* No side effect */


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var Caml_array = __webpack_require__(4);

	function app(_f, _args) {
	  while(true) {
	    var args = _args;
	    var f = _f;
	    var arity = f.length;
	    var arity$1 = arity ? arity : 1;
	    var len = args.length;
	    var d = arity$1 - len | 0;
	    if (d) {
	      if (d < 0) {
	        _args = Caml_array.caml_array_sub(args, arity$1, -d | 0);
	        _f = f.apply(null, Caml_array.caml_array_sub(args, 0, arity$1));
	        continue ;
	        
	      } else {
	        return (function(f,args){
	        return function (x) {
	          return app(f, args.concat(/* array */[x]));
	        }
	        }(f,args));
	      }
	    } else {
	      return f.apply(null, args);
	    }
	  };
	}

	function curry_1(o, a0, arity) {
	  if (arity > 7 || arity < 0) {
	    return app(o, /* array */[a0]);
	  } else {
	    switch (arity) {
	      case 0 : 
	      case 1 : 
	          return o(a0);
	      case 2 : 
	          return (function (param) {
	              return o(a0, param);
	            });
	      case 3 : 
	          return (function (param, param$1) {
	              return o(a0, param, param$1);
	            });
	      case 4 : 
	          return (function (param, param$1, param$2) {
	              return o(a0, param, param$1, param$2);
	            });
	      case 5 : 
	          return (function (param, param$1, param$2, param$3) {
	              return o(a0, param, param$1, param$2, param$3);
	            });
	      case 6 : 
	          return (function (param, param$1, param$2, param$3, param$4) {
	              return o(a0, param, param$1, param$2, param$3, param$4);
	            });
	      case 7 : 
	          return (function (param, param$1, param$2, param$3, param$4, param$5) {
	              return o(a0, param, param$1, param$2, param$3, param$4, param$5);
	            });
	      
	    }
	  }
	}

	function _1(o, a0) {
	  var arity = o.length;
	  if (arity === 1) {
	    return o(a0);
	  } else {
	    return curry_1(o, a0, arity);
	  }
	}

	function __1(o) {
	  var arity = o.length;
	  if (arity === 1) {
	    return o;
	  } else {
	    return (function (a0) {
	        return _1(o, a0);
	      });
	  }
	}

	function curry_2(o, a0, a1, arity) {
	  if (arity > 7 || arity < 0) {
	    return app(o, /* array */[
	                a0,
	                a1
	              ]);
	  } else {
	    switch (arity) {
	      case 0 : 
	      case 1 : 
	          return app(o(a0), /* array */[a1]);
	      case 2 : 
	          return o(a0, a1);
	      case 3 : 
	          return (function (param) {
	              return o(a0, a1, param);
	            });
	      case 4 : 
	          return (function (param, param$1) {
	              return o(a0, a1, param, param$1);
	            });
	      case 5 : 
	          return (function (param, param$1, param$2) {
	              return o(a0, a1, param, param$1, param$2);
	            });
	      case 6 : 
	          return (function (param, param$1, param$2, param$3) {
	              return o(a0, a1, param, param$1, param$2, param$3);
	            });
	      case 7 : 
	          return (function (param, param$1, param$2, param$3, param$4) {
	              return o(a0, a1, param, param$1, param$2, param$3, param$4);
	            });
	      
	    }
	  }
	}

	function _2(o, a0, a1) {
	  var arity = o.length;
	  if (arity === 2) {
	    return o(a0, a1);
	  } else {
	    return curry_2(o, a0, a1, arity);
	  }
	}

	function __2(o) {
	  var arity = o.length;
	  if (arity === 2) {
	    return o;
	  } else {
	    return (function (a0, a1) {
	        return _2(o, a0, a1);
	      });
	  }
	}

	function curry_3(o, a0, a1, a2, arity) {
	  var exit = 0;
	  if (arity > 7 || arity < 0) {
	    return app(o, /* array */[
	                a0,
	                a1,
	                a2
	              ]);
	  } else {
	    switch (arity) {
	      case 0 : 
	      case 1 : 
	          exit = 1;
	          break;
	      case 2 : 
	          return app(o(a0, a1), /* array */[a2]);
	      case 3 : 
	          return o(a0, a1, a2);
	      case 4 : 
	          return (function (param) {
	              return o(a0, a1, a2, param);
	            });
	      case 5 : 
	          return (function (param, param$1) {
	              return o(a0, a1, a2, param, param$1);
	            });
	      case 6 : 
	          return (function (param, param$1, param$2) {
	              return o(a0, a1, a2, param, param$1, param$2);
	            });
	      case 7 : 
	          return (function (param, param$1, param$2, param$3) {
	              return o(a0, a1, a2, param, param$1, param$2, param$3);
	            });
	      
	    }
	  }
	  if (exit === 1) {
	    return app(o(a0), /* array */[
	                a1,
	                a2
	              ]);
	  }
	  
	}

	function _3(o, a0, a1, a2) {
	  var arity = o.length;
	  if (arity === 3) {
	    return o(a0, a1, a2);
	  } else {
	    return curry_3(o, a0, a1, a2, arity);
	  }
	}

	function __3(o) {
	  var arity = o.length;
	  if (arity === 3) {
	    return o;
	  } else {
	    return (function (a0, a1, a2) {
	        return _3(o, a0, a1, a2);
	      });
	  }
	}

	function curry_4(o, a0, a1, a2, a3, arity) {
	  var exit = 0;
	  if (arity > 7 || arity < 0) {
	    return app(o, /* array */[
	                a0,
	                a1,
	                a2,
	                a3
	              ]);
	  } else {
	    switch (arity) {
	      case 0 : 
	      case 1 : 
	          exit = 1;
	          break;
	      case 2 : 
	          return app(o(a0, a1), /* array */[
	                      a2,
	                      a3
	                    ]);
	      case 3 : 
	          return app(o(a0, a1, a2), /* array */[a3]);
	      case 4 : 
	          return o(a0, a1, a2, a3);
	      case 5 : 
	          return (function (param) {
	              return o(a0, a1, a2, a3, param);
	            });
	      case 6 : 
	          return (function (param, param$1) {
	              return o(a0, a1, a2, a3, param, param$1);
	            });
	      case 7 : 
	          return (function (param, param$1, param$2) {
	              return o(a0, a1, a2, a3, param, param$1, param$2);
	            });
	      
	    }
	  }
	  if (exit === 1) {
	    return app(o(a0), /* array */[
	                a1,
	                a2,
	                a3
	              ]);
	  }
	  
	}

	function _4(o, a0, a1, a2, a3) {
	  var arity = o.length;
	  if (arity === 4) {
	    return o(a0, a1, a2, a3);
	  } else {
	    return curry_4(o, a0, a1, a2, a3, arity);
	  }
	}

	function __4(o) {
	  var arity = o.length;
	  if (arity === 4) {
	    return o;
	  } else {
	    return (function (a0, a1, a2, a3) {
	        return _4(o, a0, a1, a2, a3);
	      });
	  }
	}

	function curry_5(o, a0, a1, a2, a3, a4, arity) {
	  var exit = 0;
	  if (arity > 7 || arity < 0) {
	    return app(o, /* array */[
	                a0,
	                a1,
	                a2,
	                a3,
	                a4
	              ]);
	  } else {
	    switch (arity) {
	      case 0 : 
	      case 1 : 
	          exit = 1;
	          break;
	      case 2 : 
	          return app(o(a0, a1), /* array */[
	                      a2,
	                      a3,
	                      a4
	                    ]);
	      case 3 : 
	          return app(o(a0, a1, a2), /* array */[
	                      a3,
	                      a4
	                    ]);
	      case 4 : 
	          return app(o(a0, a1, a2, a3), /* array */[a4]);
	      case 5 : 
	          return o(a0, a1, a2, a3, a4);
	      case 6 : 
	          return (function (param) {
	              return o(a0, a1, a2, a3, a4, param);
	            });
	      case 7 : 
	          return (function (param, param$1) {
	              return o(a0, a1, a2, a3, a4, param, param$1);
	            });
	      
	    }
	  }
	  if (exit === 1) {
	    return app(o(a0), /* array */[
	                a1,
	                a2,
	                a3,
	                a4
	              ]);
	  }
	  
	}

	function _5(o, a0, a1, a2, a3, a4) {
	  var arity = o.length;
	  if (arity === 5) {
	    return o(a0, a1, a2, a3, a4);
	  } else {
	    return curry_5(o, a0, a1, a2, a3, a4, arity);
	  }
	}

	function __5(o) {
	  var arity = o.length;
	  if (arity === 5) {
	    return o;
	  } else {
	    return (function (a0, a1, a2, a3, a4) {
	        return _5(o, a0, a1, a2, a3, a4);
	      });
	  }
	}

	function curry_6(o, a0, a1, a2, a3, a4, a5, arity) {
	  var exit = 0;
	  if (arity > 7 || arity < 0) {
	    return app(o, /* array */[
	                a0,
	                a1,
	                a2,
	                a3,
	                a4,
	                a5
	              ]);
	  } else {
	    switch (arity) {
	      case 0 : 
	      case 1 : 
	          exit = 1;
	          break;
	      case 2 : 
	          return app(o(a0, a1), /* array */[
	                      a2,
	                      a3,
	                      a4,
	                      a5
	                    ]);
	      case 3 : 
	          return app(o(a0, a1, a2), /* array */[
	                      a3,
	                      a4,
	                      a5
	                    ]);
	      case 4 : 
	          return app(o(a0, a1, a2, a3), /* array */[
	                      a4,
	                      a5
	                    ]);
	      case 5 : 
	          return app(o(a0, a1, a2, a3, a4), /* array */[a5]);
	      case 6 : 
	          return o(a0, a1, a2, a3, a4, a5);
	      case 7 : 
	          return (function (param) {
	              return o(a0, a1, a2, a3, a4, a5, param);
	            });
	      
	    }
	  }
	  if (exit === 1) {
	    return app(o(a0), /* array */[
	                a1,
	                a2,
	                a3,
	                a4,
	                a5
	              ]);
	  }
	  
	}

	function _6(o, a0, a1, a2, a3, a4, a5) {
	  var arity = o.length;
	  if (arity === 6) {
	    return o(a0, a1, a2, a3, a4, a5);
	  } else {
	    return curry_6(o, a0, a1, a2, a3, a4, a5, arity);
	  }
	}

	function __6(o) {
	  var arity = o.length;
	  if (arity === 6) {
	    return o;
	  } else {
	    return (function (a0, a1, a2, a3, a4, a5) {
	        return _6(o, a0, a1, a2, a3, a4, a5);
	      });
	  }
	}

	function curry_7(o, a0, a1, a2, a3, a4, a5, a6, arity) {
	  var exit = 0;
	  if (arity > 7 || arity < 0) {
	    return app(o, /* array */[
	                a0,
	                a1,
	                a2,
	                a3,
	                a4,
	                a5,
	                a6
	              ]);
	  } else {
	    switch (arity) {
	      case 0 : 
	      case 1 : 
	          exit = 1;
	          break;
	      case 2 : 
	          return app(o(a0, a1), /* array */[
	                      a2,
	                      a3,
	                      a4,
	                      a5,
	                      a6
	                    ]);
	      case 3 : 
	          return app(o(a0, a1, a2), /* array */[
	                      a3,
	                      a4,
	                      a5,
	                      a6
	                    ]);
	      case 4 : 
	          return app(o(a0, a1, a2, a3), /* array */[
	                      a4,
	                      a5,
	                      a6
	                    ]);
	      case 5 : 
	          return app(o(a0, a1, a2, a3, a4), /* array */[
	                      a5,
	                      a6
	                    ]);
	      case 6 : 
	          return app(o(a0, a1, a2, a3, a4, a5), /* array */[a6]);
	      case 7 : 
	          return o(a0, a1, a2, a3, a4, a5, a6);
	      
	    }
	  }
	  if (exit === 1) {
	    return app(o(a0), /* array */[
	                a1,
	                a2,
	                a3,
	                a4,
	                a5,
	                a6
	              ]);
	  }
	  
	}

	function _7(o, a0, a1, a2, a3, a4, a5, a6) {
	  var arity = o.length;
	  if (arity === 7) {
	    return o(a0, a1, a2, a3, a4, a5, a6);
	  } else {
	    return curry_7(o, a0, a1, a2, a3, a4, a5, a6, arity);
	  }
	}

	function __7(o) {
	  var arity = o.length;
	  if (arity === 7) {
	    return o;
	  } else {
	    return (function (a0, a1, a2, a3, a4, a5, a6) {
	        return _7(o, a0, a1, a2, a3, a4, a5, a6);
	      });
	  }
	}

	function curry_8(o, a0, a1, a2, a3, a4, a5, a6, a7, arity) {
	  var exit = 0;
	  if (arity > 7 || arity < 0) {
	    return app(o, /* array */[
	                a0,
	                a1,
	                a2,
	                a3,
	                a4,
	                a5,
	                a6,
	                a7
	              ]);
	  } else {
	    switch (arity) {
	      case 0 : 
	      case 1 : 
	          exit = 1;
	          break;
	      case 2 : 
	          return app(o(a0, a1), /* array */[
	                      a2,
	                      a3,
	                      a4,
	                      a5,
	                      a6,
	                      a7
	                    ]);
	      case 3 : 
	          return app(o(a0, a1, a2), /* array */[
	                      a3,
	                      a4,
	                      a5,
	                      a6,
	                      a7
	                    ]);
	      case 4 : 
	          return app(o(a0, a1, a2, a3), /* array */[
	                      a4,
	                      a5,
	                      a6,
	                      a7
	                    ]);
	      case 5 : 
	          return app(o(a0, a1, a2, a3, a4), /* array */[
	                      a5,
	                      a6,
	                      a7
	                    ]);
	      case 6 : 
	          return app(o(a0, a1, a2, a3, a4, a5), /* array */[
	                      a6,
	                      a7
	                    ]);
	      case 7 : 
	          return app(o(a0, a1, a2, a3, a4, a5, a6), /* array */[a7]);
	      
	    }
	  }
	  if (exit === 1) {
	    return app(o(a0), /* array */[
	                a1,
	                a2,
	                a3,
	                a4,
	                a5,
	                a6,
	                a7
	              ]);
	  }
	  
	}

	function _8(o, a0, a1, a2, a3, a4, a5, a6, a7) {
	  var arity = o.length;
	  if (arity === 8) {
	    return o(a0, a1, a2, a3, a4, a5, a6, a7);
	  } else {
	    return curry_8(o, a0, a1, a2, a3, a4, a5, a6, a7, arity);
	  }
	}

	function __8(o) {
	  var arity = o.length;
	  if (arity === 8) {
	    return o;
	  } else {
	    return (function (a0, a1, a2, a3, a4, a5, a6, a7) {
	        return _8(o, a0, a1, a2, a3, a4, a5, a6, a7);
	      });
	  }
	}

	exports.app     = app;
	exports.curry_1 = curry_1;
	exports._1      = _1;
	exports.__1     = __1;
	exports.curry_2 = curry_2;
	exports._2      = _2;
	exports.__2     = __2;
	exports.curry_3 = curry_3;
	exports._3      = _3;
	exports.__3     = __3;
	exports.curry_4 = curry_4;
	exports._4      = _4;
	exports.__4     = __4;
	exports.curry_5 = curry_5;
	exports._5      = _5;
	exports.__5     = __5;
	exports.curry_6 = curry_6;
	exports._6      = _6;
	exports.__6     = __6;
	exports.curry_7 = curry_7;
	exports._7      = _7;
	exports.__7     = __7;
	exports.curry_8 = curry_8;
	exports._8      = _8;
	exports.__8     = __8;
	/* No side effect */


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var Caml_builtin_exceptions = __webpack_require__(5);

	function caml_array_sub(x, offset, len) {
	  var result = new Array(len);
	  var j = 0;
	  var i = offset;
	  while(j < len) {
	    result[j] = x[i];
	    j = j + 1 | 0;
	    i = i + 1 | 0;
	  };
	  return result;
	}

	function len(_acc, _l) {
	  while(true) {
	    var l = _l;
	    var acc = _acc;
	    if (l) {
	      _l = l[1];
	      _acc = l[0].length + acc | 0;
	      continue ;
	      
	    } else {
	      return acc;
	    }
	  };
	}

	function fill(arr, _i, _l) {
	  while(true) {
	    var l = _l;
	    var i = _i;
	    if (l) {
	      var x = l[0];
	      var l$1 = x.length;
	      var k = i;
	      var j = 0;
	      while(j < l$1) {
	        arr[k] = x[j];
	        k = k + 1 | 0;
	        j = j + 1 | 0;
	      };
	      _l = l[1];
	      _i = k;
	      continue ;
	      
	    } else {
	      return /* () */0;
	    }
	  };
	}

	function caml_array_concat(l) {
	  var v = len(0, l);
	  var result = new Array(v);
	  fill(result, 0, l);
	  return result;
	}

	function caml_array_set(xs, index, newval) {
	  if (index < 0 || index >= xs.length) {
	    throw [
	          Caml_builtin_exceptions.invalid_argument,
	          "index out of bounds"
	        ];
	  } else {
	    xs[index] = newval;
	    return /* () */0;
	  }
	}

	function caml_array_get(xs, index) {
	  if (index < 0 || index >= xs.length) {
	    throw [
	          Caml_builtin_exceptions.invalid_argument,
	          "index out of bounds"
	        ];
	  } else {
	    return xs[index];
	  }
	}

	function caml_make_vect(len, init) {
	  var b = new Array(len);
	  for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
	    b[i] = init;
	  }
	  return b;
	}

	function caml_array_blit(a1, i1, a2, i2, len) {
	  if (i2 <= i1) {
	    for(var j = 0 ,j_finish = len - 1 | 0; j <= j_finish; ++j){
	      a2[j + i2 | 0] = a1[j + i1 | 0];
	    }
	    return /* () */0;
	  } else {
	    for(var j$1 = len - 1 | 0; j$1 >= 0; --j$1){
	      a2[j$1 + i2 | 0] = a1[j$1 + i1 | 0];
	    }
	    return /* () */0;
	  }
	}

	exports.caml_array_sub    = caml_array_sub;
	exports.caml_array_concat = caml_array_concat;
	exports.caml_make_vect    = caml_make_vect;
	exports.caml_array_blit   = caml_array_blit;
	exports.caml_array_get    = caml_array_get;
	exports.caml_array_set    = caml_array_set;
	/* No side effect */


/***/ }),
/* 5 */
/***/ (function(module, exports) {

	'use strict';


	var out_of_memory = /* tuple */[
	  "Out_of_memory",
	  0
	];

	var sys_error = /* tuple */[
	  "Sys_error",
	  -1
	];

	var failure = /* tuple */[
	  "Failure",
	  -2
	];

	var invalid_argument = /* tuple */[
	  "Invalid_argument",
	  -3
	];

	var end_of_file = /* tuple */[
	  "End_of_file",
	  -4
	];

	var division_by_zero = /* tuple */[
	  "Division_by_zero",
	  -5
	];

	var not_found = /* tuple */[
	  "Not_found",
	  -6
	];

	var match_failure = /* tuple */[
	  "Match_failure",
	  -7
	];

	var stack_overflow = /* tuple */[
	  "Stack_overflow",
	  -8
	];

	var sys_blocked_io = /* tuple */[
	  "Sys_blocked_io",
	  -9
	];

	var assert_failure = /* tuple */[
	  "Assert_failure",
	  -10
	];

	var undefined_recursive_module = /* tuple */[
	  "Undefined_recursive_module",
	  -11
	];

	out_of_memory.tag = 248;

	sys_error.tag = 248;

	failure.tag = 248;

	invalid_argument.tag = 248;

	end_of_file.tag = 248;

	division_by_zero.tag = 248;

	not_found.tag = 248;

	match_failure.tag = 248;

	stack_overflow.tag = 248;

	sys_blocked_io.tag = 248;

	assert_failure.tag = 248;

	undefined_recursive_module.tag = 248;

	exports.out_of_memory              = out_of_memory;
	exports.sys_error                  = sys_error;
	exports.failure                    = failure;
	exports.invalid_argument           = invalid_argument;
	exports.end_of_file                = end_of_file;
	exports.division_by_zero           = division_by_zero;
	exports.not_found                  = not_found;
	exports.match_failure              = match_failure;
	exports.stack_overflow             = stack_overflow;
	exports.sys_blocked_io             = sys_blocked_io;
	exports.assert_failure             = assert_failure;
	exports.undefined_recursive_module = undefined_recursive_module;
	/*  Not a pure module */


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var Block                   = __webpack_require__(7);
	var Caml_builtin_exceptions = __webpack_require__(5);

	function caml_obj_dup(x) {
	  var len = x.length | 0;
	  var v = new Array(len);
	  for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
	    v[i] = x[i];
	  }
	  v.tag = x.tag | 0;
	  return v;
	}

	function caml_obj_truncate(x, new_size) {
	  var len = x.length | 0;
	  if (new_size <= 0 || new_size > len) {
	    throw [
	          Caml_builtin_exceptions.invalid_argument,
	          "Obj.truncate"
	        ];
	  } else if (len !== new_size) {
	    for(var i = new_size ,i_finish = len - 1 | 0; i <= i_finish; ++i){
	      x[i] = 0;
	    }
	    x.length = new_size;
	    return /* () */0;
	  } else {
	    return 0;
	  }
	}

	function caml_lazy_make_forward(x) {
	  return Block.__(250, [x]);
	}

	function caml_update_dummy(x, y) {
	  var len = y.length | 0;
	  for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
	    x[i] = y[i];
	  }
	  var y_tag = y.tag | 0;
	  if (y_tag !== 0) {
	    x.tag = y_tag;
	    return /* () */0;
	  } else {
	    return 0;
	  }
	}

	function caml_int_compare(x, y) {
	  if (x < y) {
	    return -1;
	  } else if (x === y) {
	    return 0;
	  } else {
	    return 1;
	  }
	}

	function caml_compare(_a, _b) {
	  while(true) {
	    var b = _b;
	    var a = _a;
	    var a_type = typeof a;
	    var b_type = typeof b;
	    if (a_type === "string") {
	      var x = a;
	      var y = b;
	      if (x < y) {
	        return -1;
	      } else if (x === y) {
	        return 0;
	      } else {
	        return 1;
	      }
	    } else {
	      var is_a_number = +(a_type === "number");
	      var is_b_number = +(b_type === "number");
	      if (is_a_number !== 0) {
	        if (is_b_number !== 0) {
	          return caml_int_compare(a, b);
	        } else {
	          return -1;
	        }
	      } else if (is_b_number !== 0) {
	        return 1;
	      } else if (a_type === "boolean" || a_type === "undefined" || a === null) {
	        var x$1 = a;
	        var y$1 = b;
	        if (x$1 === y$1) {
	          return 0;
	        } else if (x$1 < y$1) {
	          return -1;
	        } else {
	          return 1;
	        }
	      } else if (a_type === "function" || b_type === "function") {
	        throw [
	              Caml_builtin_exceptions.invalid_argument,
	              "compare: functional value"
	            ];
	      } else {
	        var tag_a = a.tag | 0;
	        var tag_b = b.tag | 0;
	        if (tag_a === 250) {
	          _a = a[0];
	          continue ;
	          
	        } else if (tag_b === 250) {
	          _b = b[0];
	          continue ;
	          
	        } else if (tag_a === 248) {
	          return caml_int_compare(a[1], b[1]);
	        } else if (tag_a === 251) {
	          throw [
	                Caml_builtin_exceptions.invalid_argument,
	                "equal: abstract value"
	              ];
	        } else if (tag_a !== tag_b) {
	          if (tag_a < tag_b) {
	            return -1;
	          } else {
	            return 1;
	          }
	        } else {
	          var len_a = a.length | 0;
	          var len_b = b.length | 0;
	          if (len_a === len_b) {
	            var a$1 = a;
	            var b$1 = b;
	            var _i = 0;
	            var same_length = len_a;
	            while(true) {
	              var i = _i;
	              if (i === same_length) {
	                return 0;
	              } else {
	                var res = caml_compare(a$1[i], b$1[i]);
	                if (res !== 0) {
	                  return res;
	                } else {
	                  _i = i + 1 | 0;
	                  continue ;
	                  
	                }
	              }
	            };
	          } else if (len_a < len_b) {
	            var a$2 = a;
	            var b$2 = b;
	            var _i$1 = 0;
	            var short_length = len_a;
	            while(true) {
	              var i$1 = _i$1;
	              if (i$1 === short_length) {
	                return -1;
	              } else {
	                var res$1 = caml_compare(a$2[i$1], b$2[i$1]);
	                if (res$1 !== 0) {
	                  return res$1;
	                } else {
	                  _i$1 = i$1 + 1 | 0;
	                  continue ;
	                  
	                }
	              }
	            };
	          } else {
	            var a$3 = a;
	            var b$3 = b;
	            var _i$2 = 0;
	            var short_length$1 = len_b;
	            while(true) {
	              var i$2 = _i$2;
	              if (i$2 === short_length$1) {
	                return 1;
	              } else {
	                var res$2 = caml_compare(a$3[i$2], b$3[i$2]);
	                if (res$2 !== 0) {
	                  return res$2;
	                } else {
	                  _i$2 = i$2 + 1 | 0;
	                  continue ;
	                  
	                }
	              }
	            };
	          }
	        }
	      }
	    }
	  };
	}

	function caml_equal(_a, _b) {
	  while(true) {
	    var b = _b;
	    var a = _a;
	    if (a === b) {
	      return /* true */1;
	    } else {
	      var a_type = typeof a;
	      if (a_type === "string" || a_type === "number" || a_type === "boolean" || a_type === "undefined" || a === null) {
	        return /* false */0;
	      } else {
	        var b_type = typeof b;
	        if (a_type === "function" || b_type === "function") {
	          throw [
	                Caml_builtin_exceptions.invalid_argument,
	                "equal: functional value"
	              ];
	        } else if (b_type === "number" || b_type === "undefined" || b === null) {
	          return /* false */0;
	        } else {
	          var tag_a = a.tag | 0;
	          var tag_b = b.tag | 0;
	          if (tag_a === 250) {
	            _a = a[0];
	            continue ;
	            
	          } else if (tag_b === 250) {
	            _b = b[0];
	            continue ;
	            
	          } else if (tag_a === 248) {
	            return +(a[1] === b[1]);
	          } else if (tag_a === 251) {
	            throw [
	                  Caml_builtin_exceptions.invalid_argument,
	                  "equal: abstract value"
	                ];
	          } else if (tag_a !== tag_b) {
	            return /* false */0;
	          } else {
	            var len_a = a.length | 0;
	            var len_b = b.length | 0;
	            if (len_a === len_b) {
	              var a$1 = a;
	              var b$1 = b;
	              var _i = 0;
	              var same_length = len_a;
	              while(true) {
	                var i = _i;
	                if (i === same_length) {
	                  return /* true */1;
	                } else if (caml_equal(a$1[i], b$1[i])) {
	                  _i = i + 1 | 0;
	                  continue ;
	                  
	                } else {
	                  return /* false */0;
	                }
	              };
	            } else {
	              return /* false */0;
	            }
	          }
	        }
	      }
	    }
	  };
	}

	function caml_notequal(a, b) {
	  return 1 - caml_equal(a, b);
	}

	function caml_greaterequal(a, b) {
	  return +(caml_compare(a, b) >= 0);
	}

	function caml_greaterthan(a, b) {
	  return +(caml_compare(a, b) > 0);
	}

	function caml_lessequal(a, b) {
	  return +(caml_compare(a, b) <= 0);
	}

	function caml_lessthan(a, b) {
	  return +(caml_compare(a, b) < 0);
	}

	var caml_int32_compare = caml_int_compare;

	var caml_nativeint_compare = caml_int_compare;

	exports.caml_obj_dup           = caml_obj_dup;
	exports.caml_obj_truncate      = caml_obj_truncate;
	exports.caml_lazy_make_forward = caml_lazy_make_forward;
	exports.caml_update_dummy      = caml_update_dummy;
	exports.caml_int_compare       = caml_int_compare;
	exports.caml_int32_compare     = caml_int32_compare;
	exports.caml_nativeint_compare = caml_nativeint_compare;
	exports.caml_compare           = caml_compare;
	exports.caml_equal             = caml_equal;
	exports.caml_notequal          = caml_notequal;
	exports.caml_greaterequal      = caml_greaterequal;
	exports.caml_greaterthan       = caml_greaterthan;
	exports.caml_lessthan          = caml_lessthan;
	exports.caml_lessequal         = caml_lessequal;
	/* No side effect */


/***/ }),
/* 7 */
/***/ (function(module, exports) {

	'use strict';


	function __(tag, block) {
	  block.tag = tag;
	  return block;
	}

	exports.__ = __;
	/* No side effect */


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var Curry                    = __webpack_require__(3);
	var Caml_io                  = __webpack_require__(9);
	var Caml_obj                 = __webpack_require__(6);
	var Caml_sys                 = __webpack_require__(11);
	var Caml_format              = __webpack_require__(12);
	var Caml_string              = __webpack_require__(16);
	var Caml_exceptions          = __webpack_require__(17);
	var Caml_missing_polyfill    = __webpack_require__(18);
	var Caml_builtin_exceptions  = __webpack_require__(5);
	var CamlinternalFormatBasics = __webpack_require__(19);

	function failwith(s) {
	  throw [
	        Caml_builtin_exceptions.failure,
	        s
	      ];
	}

	function invalid_arg(s) {
	  throw [
	        Caml_builtin_exceptions.invalid_argument,
	        s
	      ];
	}

	var Exit = Caml_exceptions.create("Pervasives.Exit");

	function min(x, y) {
	  if (Caml_obj.caml_lessequal(x, y)) {
	    return x;
	  } else {
	    return y;
	  }
	}

	function max(x, y) {
	  if (Caml_obj.caml_greaterequal(x, y)) {
	    return x;
	  } else {
	    return y;
	  }
	}

	function abs(x) {
	  if (x >= 0) {
	    return x;
	  } else {
	    return -x | 0;
	  }
	}

	function lnot(x) {
	  return x ^ -1;
	}

	var min_int = -2147483648;

	function $caret(a, b) {
	  return a + b;
	}

	function char_of_int(n) {
	  if (n < 0 || n > 255) {
	    throw [
	          Caml_builtin_exceptions.invalid_argument,
	          "char_of_int"
	        ];
	  } else {
	    return n;
	  }
	}

	function string_of_bool(b) {
	  if (b) {
	    return "true";
	  } else {
	    return "false";
	  }
	}

	function bool_of_string(param) {
	  switch (param) {
	    case "false" : 
	        return /* false */0;
	    case "true" : 
	        return /* true */1;
	    default:
	      throw [
	            Caml_builtin_exceptions.invalid_argument,
	            "bool_of_string"
	          ];
	  }
	}

	function string_of_int(param) {
	  return "" + param;
	}

	function valid_float_lexem(s) {
	  var l = s.length;
	  var _i = 0;
	  while(true) {
	    var i = _i;
	    if (i >= l) {
	      return $caret(s, ".");
	    } else {
	      var match = Caml_string.get(s, i);
	      if (match >= 48) {
	        if (match >= 58) {
	          return s;
	        } else {
	          _i = i + 1 | 0;
	          continue ;
	          
	        }
	      } else if (match !== 45) {
	        return s;
	      } else {
	        _i = i + 1 | 0;
	        continue ;
	        
	      }
	    }
	  };
	}

	function string_of_float(f) {
	  return valid_float_lexem(Caml_format.caml_format_float("%.12g", f));
	}

	function $at(l1, l2) {
	  if (l1) {
	    return /* :: */[
	            l1[0],
	            $at(l1[1], l2)
	          ];
	  } else {
	    return l2;
	  }
	}

	var stdin = Caml_io.stdin;

	var stdout = Caml_io.stdout;

	var stderr = Caml_io.stderr;

	function open_out_gen(_, _$1, _$2) {
	  return Caml_io.caml_ml_open_descriptor_out(Caml_missing_polyfill.not_implemented("caml_sys_open not implemented by bucklescript yet\n"));
	}

	function open_out(name) {
	  return open_out_gen(/* :: */[
	              /* Open_wronly */1,
	              /* :: */[
	                /* Open_creat */3,
	                /* :: */[
	                  /* Open_trunc */4,
	                  /* :: */[
	                    /* Open_text */7,
	                    /* [] */0
	                  ]
	                ]
	              ]
	            ], 438, name);
	}

	function open_out_bin(name) {
	  return open_out_gen(/* :: */[
	              /* Open_wronly */1,
	              /* :: */[
	                /* Open_creat */3,
	                /* :: */[
	                  /* Open_trunc */4,
	                  /* :: */[
	                    /* Open_binary */6,
	                    /* [] */0
	                  ]
	                ]
	              ]
	            ], 438, name);
	}

	function flush_all() {
	  var _param = Caml_io.caml_ml_out_channels_list(/* () */0);
	  while(true) {
	    var param = _param;
	    if (param) {
	      try {
	        Caml_io.caml_ml_flush(param[0]);
	      }
	      catch (exn){
	        
	      }
	      _param = param[1];
	      continue ;
	      
	    } else {
	      return /* () */0;
	    }
	  };
	}

	function output_bytes(oc, s) {
	  return Caml_io.caml_ml_output(oc, s, 0, s.length);
	}

	function output_string(oc, s) {
	  return Caml_io.caml_ml_output(oc, s, 0, s.length);
	}

	function output(oc, s, ofs, len) {
	  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
	    throw [
	          Caml_builtin_exceptions.invalid_argument,
	          "output"
	        ];
	  } else {
	    return Caml_io.caml_ml_output(oc, s, ofs, len);
	  }
	}

	function output_substring(oc, s, ofs, len) {
	  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
	    throw [
	          Caml_builtin_exceptions.invalid_argument,
	          "output_substring"
	        ];
	  } else {
	    return Caml_io.caml_ml_output(oc, s, ofs, len);
	  }
	}

	function output_value(_, _$1) {
	  return Caml_missing_polyfill.not_implemented("caml_output_value not implemented by bucklescript yet\n");
	}

	function close_out(oc) {
	  Caml_io.caml_ml_flush(oc);
	  return Caml_missing_polyfill.not_implemented("caml_ml_close_channel not implemented by bucklescript yet\n");
	}

	function close_out_noerr(oc) {
	  try {
	    Caml_io.caml_ml_flush(oc);
	  }
	  catch (exn){
	    
	  }
	  try {
	    return Caml_missing_polyfill.not_implemented("caml_ml_close_channel not implemented by bucklescript yet\n");
	  }
	  catch (exn$1){
	    return /* () */0;
	  }
	}

	function open_in_gen(_, _$1, _$2) {
	  return Caml_io.caml_ml_open_descriptor_in(Caml_missing_polyfill.not_implemented("caml_sys_open not implemented by bucklescript yet\n"));
	}

	function open_in(name) {
	  return open_in_gen(/* :: */[
	              /* Open_rdonly */0,
	              /* :: */[
	                /* Open_text */7,
	                /* [] */0
	              ]
	            ], 0, name);
	}

	function open_in_bin(name) {
	  return open_in_gen(/* :: */[
	              /* Open_rdonly */0,
	              /* :: */[
	                /* Open_binary */6,
	                /* [] */0
	              ]
	            ], 0, name);
	}

	function input(_, s, ofs, len) {
	  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
	    throw [
	          Caml_builtin_exceptions.invalid_argument,
	          "input"
	        ];
	  } else {
	    return Caml_missing_polyfill.not_implemented("caml_ml_input not implemented by bucklescript yet\n");
	  }
	}

	function unsafe_really_input(_, _$1, _ofs, _len) {
	  while(true) {
	    var len = _len;
	    var ofs = _ofs;
	    if (len <= 0) {
	      return /* () */0;
	    } else {
	      var r = Caml_missing_polyfill.not_implemented("caml_ml_input not implemented by bucklescript yet\n");
	      if (r) {
	        _len = len - r | 0;
	        _ofs = ofs + r | 0;
	        continue ;
	        
	      } else {
	        throw Caml_builtin_exceptions.end_of_file;
	      }
	    }
	  };
	}

	function really_input(ic, s, ofs, len) {
	  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
	    throw [
	          Caml_builtin_exceptions.invalid_argument,
	          "really_input"
	        ];
	  } else {
	    return unsafe_really_input(ic, s, ofs, len);
	  }
	}

	function really_input_string(ic, len) {
	  var s = Caml_string.caml_create_string(len);
	  really_input(ic, s, 0, len);
	  return Caml_string.bytes_to_string(s);
	}

	function input_line(chan) {
	  var build_result = function (buf, _pos, _param) {
	    while(true) {
	      var param = _param;
	      var pos = _pos;
	      if (param) {
	        var hd = param[0];
	        var len = hd.length;
	        Caml_string.caml_blit_bytes(hd, 0, buf, pos - len | 0, len);
	        _param = param[1];
	        _pos = pos - len | 0;
	        continue ;
	        
	      } else {
	        return buf;
	      }
	    };
	  };
	  var scan = function (_accu, _len) {
	    while(true) {
	      var len = _len;
	      var accu = _accu;
	      var n = Caml_missing_polyfill.not_implemented("caml_ml_input_scan_line not implemented by bucklescript yet\n");
	      if (n) {
	        if (n > 0) {
	          var res = Caml_string.caml_create_string(n - 1 | 0);
	          Caml_missing_polyfill.not_implemented("caml_ml_input not implemented by bucklescript yet\n");
	          Caml_io.caml_ml_input_char(chan);
	          if (accu) {
	            var len$1 = (len + n | 0) - 1 | 0;
	            return build_result(Caml_string.caml_create_string(len$1), len$1, /* :: */[
	                        res,
	                        accu
	                      ]);
	          } else {
	            return res;
	          }
	        } else {
	          var beg = Caml_string.caml_create_string(-n | 0);
	          Caml_missing_polyfill.not_implemented("caml_ml_input not implemented by bucklescript yet\n");
	          _len = len - n | 0;
	          _accu = /* :: */[
	            beg,
	            accu
	          ];
	          continue ;
	          
	        }
	      } else if (accu) {
	        return build_result(Caml_string.caml_create_string(len), len, accu);
	      } else {
	        throw Caml_builtin_exceptions.end_of_file;
	      }
	    };
	  };
	  return Caml_string.bytes_to_string(scan(/* [] */0, 0));
	}

	function close_in_noerr() {
	  try {
	    return Caml_missing_polyfill.not_implemented("caml_ml_close_channel not implemented by bucklescript yet\n");
	  }
	  catch (exn){
	    return /* () */0;
	  }
	}

	function print_char(c) {
	  return Caml_io.caml_ml_output_char(stdout, c);
	}

	function print_string(s) {
	  return output_string(stdout, s);
	}

	function print_bytes(s) {
	  return output_bytes(stdout, s);
	}

	function print_int(i) {
	  return output_string(stdout, "" + i);
	}

	function print_float(f) {
	  return output_string(stdout, valid_float_lexem(Caml_format.caml_format_float("%.12g", f)));
	}

	function print_endline(param) {
	  console.log(param);
	  return 0;
	}

	function print_newline() {
	  Caml_io.caml_ml_output_char(stdout, /* "\n" */10);
	  return Caml_io.caml_ml_flush(stdout);
	}

	function prerr_char(c) {
	  return Caml_io.caml_ml_output_char(stderr, c);
	}

	function prerr_string(s) {
	  return output_string(stderr, s);
	}

	function prerr_bytes(s) {
	  return output_bytes(stderr, s);
	}

	function prerr_int(i) {
	  return output_string(stderr, "" + i);
	}

	function prerr_float(f) {
	  return output_string(stderr, valid_float_lexem(Caml_format.caml_format_float("%.12g", f)));
	}

	function prerr_endline(param) {
	  console.error(param);
	  return 0;
	}

	function prerr_newline() {
	  Caml_io.caml_ml_output_char(stderr, /* "\n" */10);
	  return Caml_io.caml_ml_flush(stderr);
	}

	function read_line() {
	  Caml_io.caml_ml_flush(stdout);
	  return input_line(stdin);
	}

	function read_int() {
	  return Caml_format.caml_int_of_string((Caml_io.caml_ml_flush(stdout), input_line(stdin)));
	}

	function read_float() {
	  return Caml_format.caml_float_of_string((Caml_io.caml_ml_flush(stdout), input_line(stdin)));
	}

	function string_of_format(param) {
	  return param[1];
	}

	function $caret$caret(param, param$1) {
	  return /* Format */[
	          CamlinternalFormatBasics.concat_fmt(param[0], param$1[0]),
	          $caret(param[1], $caret("%,", param$1[1]))
	        ];
	}

	var exit_function = [flush_all];

	function at_exit(f) {
	  var g = exit_function[0];
	  exit_function[0] = (function () {
	      Curry._1(f, /* () */0);
	      return Curry._1(g, /* () */0);
	    });
	  return /* () */0;
	}

	function do_at_exit() {
	  return Curry._1(exit_function[0], /* () */0);
	}

	function exit(retcode) {
	  do_at_exit(/* () */0);
	  return Caml_sys.caml_sys_exit(retcode);
	}

	var max_int = 2147483647;

	var infinity = Infinity;

	var neg_infinity = -Infinity;

	var nan = NaN;

	var max_float = Number.MAX_VALUE;

	var min_float = Number.MIN_VALUE;

	var epsilon_float = 2.220446049250313e-16;

	var flush = Caml_io.caml_ml_flush;

	var output_char = Caml_io.caml_ml_output_char;

	var output_byte = Caml_io.caml_ml_output_char;

	function output_binary_int(_, _$1) {
	  return Caml_missing_polyfill.not_implemented("caml_ml_output_int not implemented by bucklescript yet\n");
	}

	function seek_out(_, _$1) {
	  return Caml_missing_polyfill.not_implemented("caml_ml_seek_out not implemented by bucklescript yet\n");
	}

	function pos_out() {
	  return Caml_missing_polyfill.not_implemented("caml_ml_pos_out not implemented by bucklescript yet\n");
	}

	function out_channel_length() {
	  return Caml_missing_polyfill.not_implemented("caml_ml_channel_size not implemented by bucklescript yet\n");
	}

	function set_binary_mode_out(_, _$1) {
	  return Caml_missing_polyfill.not_implemented("caml_ml_set_binary_mode not implemented by bucklescript yet\n");
	}

	var input_char = Caml_io.caml_ml_input_char;

	var input_byte = Caml_io.caml_ml_input_char;

	function input_binary_int() {
	  return Caml_missing_polyfill.not_implemented("caml_ml_input_int not implemented by bucklescript yet\n");
	}

	function input_value() {
	  return Caml_missing_polyfill.not_implemented("caml_input_value not implemented by bucklescript yet\n");
	}

	function seek_in(_, _$1) {
	  return Caml_missing_polyfill.not_implemented("caml_ml_seek_in not implemented by bucklescript yet\n");
	}

	function pos_in() {
	  return Caml_missing_polyfill.not_implemented("caml_ml_pos_in not implemented by bucklescript yet\n");
	}

	function in_channel_length() {
	  return Caml_missing_polyfill.not_implemented("caml_ml_channel_size not implemented by bucklescript yet\n");
	}

	function close_in() {
	  return Caml_missing_polyfill.not_implemented("caml_ml_close_channel not implemented by bucklescript yet\n");
	}

	function set_binary_mode_in(_, _$1) {
	  return Caml_missing_polyfill.not_implemented("caml_ml_set_binary_mode not implemented by bucklescript yet\n");
	}

	function LargeFile_000(_, _$1) {
	  return Caml_missing_polyfill.not_implemented("caml_ml_seek_out_64 not implemented by bucklescript yet\n");
	}

	function LargeFile_001() {
	  return Caml_missing_polyfill.not_implemented("caml_ml_pos_out_64 not implemented by bucklescript yet\n");
	}

	function LargeFile_002() {
	  return Caml_missing_polyfill.not_implemented("caml_ml_channel_size_64 not implemented by bucklescript yet\n");
	}

	function LargeFile_003(_, _$1) {
	  return Caml_missing_polyfill.not_implemented("caml_ml_seek_in_64 not implemented by bucklescript yet\n");
	}

	function LargeFile_004() {
	  return Caml_missing_polyfill.not_implemented("caml_ml_pos_in_64 not implemented by bucklescript yet\n");
	}

	function LargeFile_005() {
	  return Caml_missing_polyfill.not_implemented("caml_ml_channel_size_64 not implemented by bucklescript yet\n");
	}

	var LargeFile = [
	  LargeFile_000,
	  LargeFile_001,
	  LargeFile_002,
	  LargeFile_003,
	  LargeFile_004,
	  LargeFile_005
	];

	exports.invalid_arg         = invalid_arg;
	exports.failwith            = failwith;
	exports.Exit                = Exit;
	exports.min                 = min;
	exports.max                 = max;
	exports.abs                 = abs;
	exports.max_int             = max_int;
	exports.min_int             = min_int;
	exports.lnot                = lnot;
	exports.infinity            = infinity;
	exports.neg_infinity        = neg_infinity;
	exports.nan                 = nan;
	exports.max_float           = max_float;
	exports.min_float           = min_float;
	exports.epsilon_float       = epsilon_float;
	exports.$caret              = $caret;
	exports.char_of_int         = char_of_int;
	exports.string_of_bool      = string_of_bool;
	exports.bool_of_string      = bool_of_string;
	exports.string_of_int       = string_of_int;
	exports.string_of_float     = string_of_float;
	exports.$at                 = $at;
	exports.stdin               = stdin;
	exports.stdout              = stdout;
	exports.stderr              = stderr;
	exports.print_char          = print_char;
	exports.print_string        = print_string;
	exports.print_bytes         = print_bytes;
	exports.print_int           = print_int;
	exports.print_float         = print_float;
	exports.print_endline       = print_endline;
	exports.print_newline       = print_newline;
	exports.prerr_char          = prerr_char;
	exports.prerr_string        = prerr_string;
	exports.prerr_bytes         = prerr_bytes;
	exports.prerr_int           = prerr_int;
	exports.prerr_float         = prerr_float;
	exports.prerr_endline       = prerr_endline;
	exports.prerr_newline       = prerr_newline;
	exports.read_line           = read_line;
	exports.read_int            = read_int;
	exports.read_float          = read_float;
	exports.open_out            = open_out;
	exports.open_out_bin        = open_out_bin;
	exports.open_out_gen        = open_out_gen;
	exports.flush               = flush;
	exports.flush_all           = flush_all;
	exports.output_char         = output_char;
	exports.output_string       = output_string;
	exports.output_bytes        = output_bytes;
	exports.output              = output;
	exports.output_substring    = output_substring;
	exports.output_byte         = output_byte;
	exports.output_binary_int   = output_binary_int;
	exports.output_value        = output_value;
	exports.seek_out            = seek_out;
	exports.pos_out             = pos_out;
	exports.out_channel_length  = out_channel_length;
	exports.close_out           = close_out;
	exports.close_out_noerr     = close_out_noerr;
	exports.set_binary_mode_out = set_binary_mode_out;
	exports.open_in             = open_in;
	exports.open_in_bin         = open_in_bin;
	exports.open_in_gen         = open_in_gen;
	exports.input_char          = input_char;
	exports.input_line          = input_line;
	exports.input               = input;
	exports.really_input        = really_input;
	exports.really_input_string = really_input_string;
	exports.input_byte          = input_byte;
	exports.input_binary_int    = input_binary_int;
	exports.input_value         = input_value;
	exports.seek_in             = seek_in;
	exports.pos_in              = pos_in;
	exports.in_channel_length   = in_channel_length;
	exports.close_in            = close_in;
	exports.close_in_noerr      = close_in_noerr;
	exports.set_binary_mode_in  = set_binary_mode_in;
	exports.LargeFile           = LargeFile;
	exports.string_of_format    = string_of_format;
	exports.$caret$caret        = $caret$caret;
	exports.exit                = exit;
	exports.at_exit             = at_exit;
	exports.valid_float_lexem   = valid_float_lexem;
	exports.unsafe_really_input = unsafe_really_input;
	exports.do_at_exit          = do_at_exit;
	/* No side effect */


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var Curry                   = __webpack_require__(3);
	var Caml_builtin_exceptions = __webpack_require__(5);

	function $caret(prim, prim$1) {
	  return prim + prim$1;
	}

	var stdin = undefined;

	var stdout = /* record */[
	  /* buffer */"",
	  /* output */(function (_, s) {
	      var v = s.length - 1 | 0;
	      if (( (typeof process !== "undefined") && process.stdout && process.stdout.write)) {
	        return ( process.stdout.write )(s);
	      } else if (s[v] === "\n") {
	        console.log(s.slice(0, v));
	        return /* () */0;
	      } else {
	        console.log(s);
	        return /* () */0;
	      }
	    })
	];

	var stderr = /* record */[
	  /* buffer */"",
	  /* output */(function (_, s) {
	      var v = s.length - 1 | 0;
	      if (s[v] === "\n") {
	        console.log(s.slice(0, v));
	        return /* () */0;
	      } else {
	        console.log(s);
	        return /* () */0;
	      }
	    })
	];

	function caml_ml_open_descriptor_in() {
	  throw [
	        Caml_builtin_exceptions.failure,
	        "caml_ml_open_descriptor_in not implemented"
	      ];
	}

	function caml_ml_open_descriptor_out() {
	  throw [
	        Caml_builtin_exceptions.failure,
	        "caml_ml_open_descriptor_out not implemented"
	      ];
	}

	function caml_ml_flush(oc) {
	  if (oc[/* buffer */0] !== "") {
	    Curry._2(oc[/* output */1], oc, oc[/* buffer */0]);
	    oc[/* buffer */0] = "";
	    return /* () */0;
	  } else {
	    return 0;
	  }
	}

	var node_std_output = (function (s){
	   return (typeof process !== "undefined") && process.stdout && (process.stdout.write(s), true);
	   }
	);

	function caml_ml_output(oc, str, offset, len) {
	  var str$1 = offset === 0 && len === str.length ? str : str.slice(offset, len);
	  if (( (typeof process !== "undefined") && process.stdout && process.stdout.write ) && oc === stdout) {
	    return ( process.stdout.write )(str$1);
	  } else {
	    var id = str$1.lastIndexOf("\n");
	    if (id < 0) {
	      oc[/* buffer */0] = oc[/* buffer */0] + str$1;
	      return /* () */0;
	    } else {
	      oc[/* buffer */0] = oc[/* buffer */0] + str$1.slice(0, id + 1 | 0);
	      caml_ml_flush(oc);
	      oc[/* buffer */0] = oc[/* buffer */0] + str$1.slice(id + 1 | 0);
	      return /* () */0;
	    }
	  }
	}

	function caml_ml_output_char(oc, $$char) {
	  return caml_ml_output(oc, String.fromCharCode($$char), 0, 1);
	}

	function caml_ml_input(_, _$1, _$2, _$3) {
	  throw [
	        Caml_builtin_exceptions.failure,
	        "caml_ml_input ic not implemented"
	      ];
	}

	function caml_ml_input_char() {
	  throw [
	        Caml_builtin_exceptions.failure,
	        "caml_ml_input_char not implemnted"
	      ];
	}

	function caml_ml_out_channels_list() {
	  return /* :: */[
	          stdout,
	          /* :: */[
	            stderr,
	            /* [] */0
	          ]
	        ];
	}

	exports.$caret                      = $caret;
	exports.stdin                       = stdin;
	exports.stdout                      = stdout;
	exports.stderr                      = stderr;
	exports.caml_ml_open_descriptor_in  = caml_ml_open_descriptor_in;
	exports.caml_ml_open_descriptor_out = caml_ml_open_descriptor_out;
	exports.caml_ml_flush               = caml_ml_flush;
	exports.node_std_output             = node_std_output;
	exports.caml_ml_output              = caml_ml_output;
	exports.caml_ml_output_char         = caml_ml_output_char;
	exports.caml_ml_input               = caml_ml_input;
	exports.caml_ml_input_char          = caml_ml_input_char;
	exports.caml_ml_out_channels_list   = caml_ml_out_channels_list;
	/* stdin Not a pure module */

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ }),
/* 10 */
/***/ (function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;

	process.listeners = function (name) { return [] }

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var Caml_builtin_exceptions = __webpack_require__(5);

	function caml_sys_getenv(s) {
	  var match = typeof (process) === "undefined" ? undefined : (process);
	  if (match !== undefined) {
	    var match$1 = match.env[s];
	    if (match$1 !== undefined) {
	      return match$1;
	    } else {
	      throw Caml_builtin_exceptions.not_found;
	    }
	  } else {
	    throw Caml_builtin_exceptions.not_found;
	  }
	}

	function caml_sys_time() {
	  var match = typeof (process) === "undefined" ? undefined : (process);
	  if (match !== undefined) {
	    return match.uptime();
	  } else {
	    return -1;
	  }
	}

	function caml_sys_random_seed() {
	  return /* array */[((Date.now() | 0) ^ 4294967295) * Math.random() | 0];
	}

	function caml_sys_system_command() {
	  return 127;
	}

	function caml_sys_getcwd() {
	  var match = typeof (process) === "undefined" ? undefined : (process);
	  if (match !== undefined) {
	    return match.cwd();
	  } else {
	    return "/";
	  }
	}

	function caml_sys_get_argv() {
	  var match = typeof (process) === "undefined" ? undefined : (process);
	  if (match !== undefined) {
	    return /* tuple */[
	            match.argv[0],
	            match.argv
	          ];
	  } else {
	    return /* tuple */[
	            "",
	            /* array */[""]
	          ];
	  }
	}

	function caml_sys_exit(exit_code) {
	  var match = typeof (process) === "undefined" ? undefined : (process);
	  if (match !== undefined) {
	    return match.exit(exit_code);
	  } else {
	    return /* () */0;
	  }
	}

	function caml_sys_is_directory() {
	  throw [
	        Caml_builtin_exceptions.failure,
	        "caml_sys_is_directory not implemented"
	      ];
	}

	function caml_sys_file_exists() {
	  throw [
	        Caml_builtin_exceptions.failure,
	        "caml_sys_file_exists not implemented"
	      ];
	}

	exports.caml_sys_getenv         = caml_sys_getenv;
	exports.caml_sys_time           = caml_sys_time;
	exports.caml_sys_random_seed    = caml_sys_random_seed;
	exports.caml_sys_system_command = caml_sys_system_command;
	exports.caml_sys_getcwd         = caml_sys_getcwd;
	exports.caml_sys_get_argv       = caml_sys_get_argv;
	exports.caml_sys_exit           = caml_sys_exit;
	exports.caml_sys_is_directory   = caml_sys_is_directory;
	exports.caml_sys_file_exists    = caml_sys_file_exists;
	/* No side effect */

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var Curry                   = __webpack_require__(3);
	var Caml_int32              = __webpack_require__(13);
	var Caml_int64              = __webpack_require__(14);
	var Caml_utils              = __webpack_require__(15);
	var Caml_builtin_exceptions = __webpack_require__(5);

	function caml_failwith(s) {
	  throw [
	        Caml_builtin_exceptions.failure,
	        s
	      ];
	}

	function parse_digit(c) {
	  if (c >= 65) {
	    if (c >= 97) {
	      if (c >= 123) {
	        return -1;
	      } else {
	        return c - 87 | 0;
	      }
	    } else if (c >= 91) {
	      return -1;
	    } else {
	      return c - 55 | 0;
	    }
	  } else if (c > 57 || c < 48) {
	    return -1;
	  } else {
	    return c - /* "0" */48 | 0;
	  }
	}

	function int_of_string_base(param) {
	  switch (param) {
	    case 0 : 
	        return 8;
	    case 1 : 
	        return 16;
	    case 2 : 
	        return 10;
	    case 3 : 
	        return 2;
	    
	  }
	}

	function parse_sign_and_base(s) {
	  var sign = 1;
	  var base = /* Dec */2;
	  var i = 0;
	  if (s[i] === "-") {
	    sign = -1;
	    i = i + 1 | 0;
	  }
	  var match = s.charCodeAt(i);
	  var match$1 = s.charCodeAt(i + 1 | 0);
	  if (match === 48) {
	    if (match$1 >= 89) {
	      if (match$1 !== 98) {
	        if (match$1 !== 111) {
	          if (match$1 === 120) {
	            base = /* Hex */1;
	            i = i + 2 | 0;
	          }
	          
	        } else {
	          base = /* Oct */0;
	          i = i + 2 | 0;
	        }
	      } else {
	        base = /* Bin */3;
	        i = i + 2 | 0;
	      }
	    } else if (match$1 !== 66) {
	      if (match$1 !== 79) {
	        if (match$1 >= 88) {
	          base = /* Hex */1;
	          i = i + 2 | 0;
	        }
	        
	      } else {
	        base = /* Oct */0;
	        i = i + 2 | 0;
	      }
	    } else {
	      base = /* Bin */3;
	      i = i + 2 | 0;
	    }
	  }
	  return /* tuple */[
	          i,
	          sign,
	          base
	        ];
	}

	function caml_int_of_string(s) {
	  var match = parse_sign_and_base(s);
	  var i = match[0];
	  var base = int_of_string_base(match[2]);
	  var threshold = 4294967295;
	  var len = s.length;
	  var c = i < len ? s.charCodeAt(i) : /* "\000" */0;
	  var d = parse_digit(c);
	  if (d < 0 || d >= base) {
	    throw [
	          Caml_builtin_exceptions.failure,
	          "int_of_string"
	        ];
	  }
	  var aux = function (_acc, _k) {
	    while(true) {
	      var k = _k;
	      var acc = _acc;
	      if (k === len) {
	        return acc;
	      } else {
	        var a = s.charCodeAt(k);
	        if (a === /* "_" */95) {
	          _k = k + 1 | 0;
	          continue ;
	          
	        } else {
	          var v = parse_digit(a);
	          if (v < 0 || v >= base) {
	            throw [
	                  Caml_builtin_exceptions.failure,
	                  "int_of_string"
	                ];
	          } else {
	            var acc$1 = base * acc + v;
	            if (acc$1 > threshold) {
	              throw [
	                    Caml_builtin_exceptions.failure,
	                    "int_of_string"
	                  ];
	            } else {
	              _k = k + 1 | 0;
	              _acc = acc$1;
	              continue ;
	              
	            }
	          }
	        }
	      }
	    };
	  };
	  var res = match[1] * aux(d, i + 1 | 0);
	  var or_res = res | 0;
	  if (base === 10 && res !== or_res) {
	    throw [
	          Caml_builtin_exceptions.failure,
	          "int_of_string"
	        ];
	  }
	  return or_res;
	}

	function caml_int64_of_string(s) {
	  var match = parse_sign_and_base(s);
	  var hbase = match[2];
	  var i = match[0];
	  var base = Caml_int64.of_int32(int_of_string_base(hbase));
	  var sign = Caml_int64.of_int32(match[1]);
	  var threshold;
	  switch (hbase) {
	    case 0 : 
	        threshold = /* int64 */[
	          /* hi */536870911,
	          /* lo */4294967295
	        ];
	        break;
	    case 1 : 
	        threshold = /* int64 */[
	          /* hi */268435455,
	          /* lo */4294967295
	        ];
	        break;
	    case 2 : 
	        threshold = /* int64 */[
	          /* hi */429496729,
	          /* lo */2576980377
	        ];
	        break;
	    case 3 : 
	        threshold = /* int64 */[
	          /* hi */2147483647,
	          /* lo */4294967295
	        ];
	        break;
	    
	  }
	  var len = s.length;
	  var c = i < len ? s.charCodeAt(i) : /* "\000" */0;
	  var d = Caml_int64.of_int32(parse_digit(c));
	  if (Caml_int64.lt(d, /* int64 */[
	          /* hi */0,
	          /* lo */0
	        ]) || Caml_int64.ge(d, base)) {
	    throw [
	          Caml_builtin_exceptions.failure,
	          "int64_of_string"
	        ];
	  }
	  var aux = function (_acc, _k) {
	    while(true) {
	      var k = _k;
	      var acc = _acc;
	      if (k === len) {
	        return acc;
	      } else {
	        var a = s.charCodeAt(k);
	        if (a === /* "_" */95) {
	          _k = k + 1 | 0;
	          continue ;
	          
	        } else {
	          var v = Caml_int64.of_int32(parse_digit(a));
	          if (Caml_int64.lt(v, /* int64 */[
	                  /* hi */0,
	                  /* lo */0
	                ]) || Caml_int64.ge(v, base) || Caml_int64.gt(acc, threshold)) {
	            throw [
	                  Caml_builtin_exceptions.failure,
	                  "int64_of_string"
	                ];
	          } else {
	            var acc$1 = Caml_int64.add(Caml_int64.mul(base, acc), v);
	            _k = k + 1 | 0;
	            _acc = acc$1;
	            continue ;
	            
	          }
	        }
	      }
	    };
	  };
	  var res = Caml_int64.mul(sign, aux(d, i + 1 | 0));
	  var or_res = Caml_int64.or_(res, /* int64 */[
	        /* hi */0,
	        /* lo */0
	      ]);
	  if (Caml_int64.eq(base, /* int64 */[
	          /* hi */0,
	          /* lo */10
	        ]) && Caml_int64.neq(res, or_res)) {
	    throw [
	          Caml_builtin_exceptions.failure,
	          "int64_of_string"
	        ];
	  }
	  return or_res;
	}

	function int_of_base(param) {
	  switch (param) {
	    case 0 : 
	        return 8;
	    case 1 : 
	        return 16;
	    case 2 : 
	        return 10;
	    
	  }
	}

	function lowercase(c) {
	  if (c >= /* "A" */65 && c <= /* "Z" */90 || c >= /* "\192" */192 && c <= /* "\214" */214 || c >= /* "\216" */216 && c <= /* "\222" */222) {
	    return c + 32 | 0;
	  } else {
	    return c;
	  }
	}

	function parse_format(fmt) {
	  var len = fmt.length;
	  if (len > 31) {
	    throw [
	          Caml_builtin_exceptions.invalid_argument,
	          "format_int: format too long"
	        ];
	  }
	  var f = /* record */[
	    /* justify */"+",
	    /* signstyle */"-",
	    /* filter */" ",
	    /* alternate : false */0,
	    /* base : Dec */2,
	    /* signedconv : false */0,
	    /* width */0,
	    /* uppercase : false */0,
	    /* sign */1,
	    /* prec */-1,
	    /* conv */"f"
	  ];
	  var _i = 0;
	  while(true) {
	    var i = _i;
	    if (i >= len) {
	      return f;
	    } else {
	      var c = fmt.charCodeAt(i);
	      var exit = 0;
	      if (c >= 69) {
	        if (c >= 88) {
	          if (c >= 121) {
	            exit = 1;
	          } else {
	            switch (c - 88 | 0) {
	              case 0 : 
	                  f[/* base */4] = /* Hex */1;
	                  f[/* uppercase */7] = /* true */1;
	                  _i = i + 1 | 0;
	                  continue ;
	                  case 13 : 
	              case 14 : 
	              case 15 : 
	                  exit = 5;
	                  break;
	              case 12 : 
	              case 17 : 
	                  exit = 4;
	                  break;
	              case 23 : 
	                  f[/* base */4] = /* Oct */0;
	                  _i = i + 1 | 0;
	                  continue ;
	                  case 29 : 
	                  f[/* base */4] = /* Dec */2;
	                  _i = i + 1 | 0;
	                  continue ;
	                  case 1 : 
	              case 2 : 
	              case 3 : 
	              case 4 : 
	              case 5 : 
	              case 6 : 
	              case 7 : 
	              case 8 : 
	              case 9 : 
	              case 10 : 
	              case 11 : 
	              case 16 : 
	              case 18 : 
	              case 19 : 
	              case 20 : 
	              case 21 : 
	              case 22 : 
	              case 24 : 
	              case 25 : 
	              case 26 : 
	              case 27 : 
	              case 28 : 
	              case 30 : 
	              case 31 : 
	                  exit = 1;
	                  break;
	              case 32 : 
	                  f[/* base */4] = /* Hex */1;
	                  _i = i + 1 | 0;
	                  continue ;
	                  
	            }
	          }
	        } else if (c >= 72) {
	          exit = 1;
	        } else {
	          f[/* signedconv */5] = /* true */1;
	          f[/* uppercase */7] = /* true */1;
	          f[/* conv */10] = String.fromCharCode(lowercase(c));
	          _i = i + 1 | 0;
	          continue ;
	          
	        }
	      } else {
	        var switcher = c - 32 | 0;
	        if (switcher > 25 || switcher < 0) {
	          exit = 1;
	        } else {
	          switch (switcher) {
	            case 3 : 
	                f[/* alternate */3] = /* true */1;
	                _i = i + 1 | 0;
	                continue ;
	                case 0 : 
	            case 11 : 
	                exit = 2;
	                break;
	            case 13 : 
	                f[/* justify */0] = "-";
	                _i = i + 1 | 0;
	                continue ;
	                case 14 : 
	                f[/* prec */9] = 0;
	                var j = i + 1 | 0;
	                while((function(j){
	                    return function () {
	                      var w = fmt.charCodeAt(j) - /* "0" */48 | 0;
	                      return +(w >= 0 && w <= 9);
	                    }
	                    }(j))()) {
	                  f[/* prec */9] = (Caml_int32.imul(f[/* prec */9], 10) + fmt.charCodeAt(j) | 0) - /* "0" */48 | 0;
	                  j = j + 1 | 0;
	                };
	                _i = j;
	                continue ;
	                case 1 : 
	            case 2 : 
	            case 4 : 
	            case 5 : 
	            case 6 : 
	            case 7 : 
	            case 8 : 
	            case 9 : 
	            case 10 : 
	            case 12 : 
	            case 15 : 
	                exit = 1;
	                break;
	            case 16 : 
	                f[/* filter */2] = "0";
	                _i = i + 1 | 0;
	                continue ;
	                case 17 : 
	            case 18 : 
	            case 19 : 
	            case 20 : 
	            case 21 : 
	            case 22 : 
	            case 23 : 
	            case 24 : 
	            case 25 : 
	                exit = 3;
	                break;
	            
	          }
	        }
	      }
	      switch (exit) {
	        case 1 : 
	            _i = i + 1 | 0;
	            continue ;
	            case 2 : 
	            f[/* signstyle */1] = String.fromCharCode(c);
	            _i = i + 1 | 0;
	            continue ;
	            case 3 : 
	            f[/* width */6] = 0;
	            var j$1 = i;
	            while((function(j$1){
	                return function () {
	                  var w = fmt.charCodeAt(j$1) - /* "0" */48 | 0;
	                  return +(w >= 0 && w <= 9);
	                }
	                }(j$1))()) {
	              f[/* width */6] = (Caml_int32.imul(f[/* width */6], 10) + fmt.charCodeAt(j$1) | 0) - /* "0" */48 | 0;
	              j$1 = j$1 + 1 | 0;
	            };
	            _i = j$1;
	            continue ;
	            case 4 : 
	            f[/* signedconv */5] = /* true */1;
	            f[/* base */4] = /* Dec */2;
	            _i = i + 1 | 0;
	            continue ;
	            case 5 : 
	            f[/* signedconv */5] = /* true */1;
	            f[/* conv */10] = String.fromCharCode(c);
	            _i = i + 1 | 0;
	            continue ;
	            
	      }
	    }
	  };
	}

	function finish_formatting(param, rawbuffer) {
	  var justify = param[/* justify */0];
	  var signstyle = param[/* signstyle */1];
	  var filter = param[/* filter */2];
	  var alternate = param[/* alternate */3];
	  var base = param[/* base */4];
	  var signedconv = param[/* signedconv */5];
	  var width = param[/* width */6];
	  var uppercase = param[/* uppercase */7];
	  var sign = param[/* sign */8];
	  var len = rawbuffer.length;
	  if (signedconv && (sign < 0 || signstyle !== "-")) {
	    len = len + 1 | 0;
	  }
	  if (alternate) {
	    if (base) {
	      if (base === /* Hex */1) {
	        len = len + 2 | 0;
	      }
	      
	    } else {
	      len = len + 1 | 0;
	    }
	  }
	  var buffer = "";
	  if (justify === "+" && filter === " ") {
	    for(var i = len ,i_finish = width - 1 | 0; i <= i_finish; ++i){
	      buffer = buffer + filter;
	    }
	  }
	  if (signedconv) {
	    if (sign < 0) {
	      buffer = buffer + "-";
	    } else if (signstyle !== "-") {
	      buffer = buffer + signstyle;
	    }
	    
	  }
	  if (alternate && base === /* Oct */0) {
	    buffer = buffer + "0";
	  }
	  if (alternate && base === /* Hex */1) {
	    buffer = buffer + "0x";
	  }
	  if (justify === "+" && filter === "0") {
	    for(var i$1 = len ,i_finish$1 = width - 1 | 0; i$1 <= i_finish$1; ++i$1){
	      buffer = buffer + filter;
	    }
	  }
	  buffer = uppercase ? buffer + rawbuffer.toUpperCase() : buffer + rawbuffer;
	  if (justify === "-") {
	    for(var i$2 = len ,i_finish$2 = width - 1 | 0; i$2 <= i_finish$2; ++i$2){
	      buffer = buffer + " ";
	    }
	  }
	  return buffer;
	}

	function caml_format_int(fmt, i) {
	  if (fmt === "%d") {
	    return String(i);
	  } else {
	    var f = parse_format(fmt);
	    var f$1 = f;
	    var i$1 = i;
	    var i$2 = i$1 < 0 ? (
	        f$1[/* signedconv */5] ? (f$1[/* sign */8] = -1, -i$1) : (i$1 >>> 0)
	      ) : i$1;
	    var s = i$2.toString(int_of_base(f$1[/* base */4]));
	    if (f$1[/* prec */9] >= 0) {
	      f$1[/* filter */2] = " ";
	      var n = f$1[/* prec */9] - s.length | 0;
	      if (n > 0) {
	        s = Caml_utils.repeat(n, "0") + s;
	      }
	      
	    }
	    return finish_formatting(f$1, s);
	  }
	}

	function caml_int64_format(fmt, x) {
	  var f = parse_format(fmt);
	  var x$1 = f[/* signedconv */5] && Caml_int64.lt(x, /* int64 */[
	        /* hi */0,
	        /* lo */0
	      ]) ? (f[/* sign */8] = -1, Caml_int64.neg(x)) : x;
	  var s = "";
	  var match = f[/* base */4];
	  switch (match) {
	    case 0 : 
	        var wbase = /* int64 */[
	          /* hi */0,
	          /* lo */8
	        ];
	        var cvtbl = "01234567";
	        if (Caml_int64.lt(x$1, /* int64 */[
	                /* hi */0,
	                /* lo */0
	              ])) {
	          var y = Caml_int64.discard_sign(x$1);
	          var match$1 = Caml_int64.div_mod(y, wbase);
	          var quotient = Caml_int64.add(/* int64 */[
	                /* hi */268435456,
	                /* lo */0
	              ], match$1[0]);
	          var modulus = match$1[1];
	          s = String.fromCharCode(cvtbl.charCodeAt(modulus[1] | 0)) + s;
	          while(Caml_int64.neq(quotient, /* int64 */[
	                  /* hi */0,
	                  /* lo */0
	                ])) {
	            var match$2 = Caml_int64.div_mod(quotient, wbase);
	            quotient = match$2[0];
	            modulus = match$2[1];
	            s = String.fromCharCode(cvtbl.charCodeAt(modulus[1] | 0)) + s;
	          };
	        } else {
	          var match$3 = Caml_int64.div_mod(x$1, wbase);
	          var quotient$1 = match$3[0];
	          var modulus$1 = match$3[1];
	          s = String.fromCharCode(cvtbl.charCodeAt(modulus$1[1] | 0)) + s;
	          while(Caml_int64.neq(quotient$1, /* int64 */[
	                  /* hi */0,
	                  /* lo */0
	                ])) {
	            var match$4 = Caml_int64.div_mod(quotient$1, wbase);
	            quotient$1 = match$4[0];
	            modulus$1 = match$4[1];
	            s = String.fromCharCode(cvtbl.charCodeAt(modulus$1[1] | 0)) + s;
	          };
	        }
	        break;
	    case 1 : 
	        s = Caml_int64.to_hex(x$1) + s;
	        break;
	    case 2 : 
	        var wbase$1 = /* int64 */[
	          /* hi */0,
	          /* lo */10
	        ];
	        var cvtbl$1 = "0123456789";
	        if (Caml_int64.lt(x$1, /* int64 */[
	                /* hi */0,
	                /* lo */0
	              ])) {
	          var y$1 = Caml_int64.discard_sign(x$1);
	          var match$5 = Caml_int64.div_mod(y$1, wbase$1);
	          var match$6 = Caml_int64.div_mod(Caml_int64.add(/* int64 */[
	                    /* hi */0,
	                    /* lo */8
	                  ], match$5[1]), wbase$1);
	          var quotient$2 = Caml_int64.add(Caml_int64.add(/* int64 */[
	                    /* hi */214748364,
	                    /* lo */3435973836
	                  ], match$5[0]), match$6[0]);
	          var modulus$2 = match$6[1];
	          s = String.fromCharCode(cvtbl$1.charCodeAt(modulus$2[1] | 0)) + s;
	          while(Caml_int64.neq(quotient$2, /* int64 */[
	                  /* hi */0,
	                  /* lo */0
	                ])) {
	            var match$7 = Caml_int64.div_mod(quotient$2, wbase$1);
	            quotient$2 = match$7[0];
	            modulus$2 = match$7[1];
	            s = String.fromCharCode(cvtbl$1.charCodeAt(modulus$2[1] | 0)) + s;
	          };
	        } else {
	          var match$8 = Caml_int64.div_mod(x$1, wbase$1);
	          var quotient$3 = match$8[0];
	          var modulus$3 = match$8[1];
	          s = String.fromCharCode(cvtbl$1.charCodeAt(modulus$3[1] | 0)) + s;
	          while(Caml_int64.neq(quotient$3, /* int64 */[
	                  /* hi */0,
	                  /* lo */0
	                ])) {
	            var match$9 = Caml_int64.div_mod(quotient$3, wbase$1);
	            quotient$3 = match$9[0];
	            modulus$3 = match$9[1];
	            s = String.fromCharCode(cvtbl$1.charCodeAt(modulus$3[1] | 0)) + s;
	          };
	        }
	        break;
	    
	  }
	  if (f[/* prec */9] >= 0) {
	    f[/* filter */2] = " ";
	    var n = f[/* prec */9] - s.length | 0;
	    if (n > 0) {
	      s = Caml_utils.repeat(n, "0") + s;
	    }
	    
	  }
	  return finish_formatting(f, s);
	}

	function caml_format_float(fmt, x) {
	  var f = parse_format(fmt);
	  var prec = f[/* prec */9] < 0 ? 6 : f[/* prec */9];
	  var x$1 = x < 0 ? (f[/* sign */8] = -1, -x) : x;
	  var s = "";
	  if (isNaN(x$1)) {
	    s = "nan";
	    f[/* filter */2] = " ";
	  } else if (isFinite(x$1)) {
	    var match = f[/* conv */10];
	    switch (match) {
	      case "e" : 
	          s = x$1.toExponential(prec);
	          var i = s.length;
	          if (s[i - 3 | 0] === "e") {
	            s = s.slice(0, i - 1 | 0) + ("0" + s.slice(i - 1 | 0));
	          }
	          break;
	      case "f" : 
	          s = x$1.toFixed(prec);
	          break;
	      case "g" : 
	          var prec$1 = prec !== 0 ? prec : 1;
	          s = x$1.toExponential(prec$1 - 1 | 0);
	          var j = s.indexOf("e");
	          var exp = Number(s.slice(j + 1 | 0)) | 0;
	          if (exp < -4 || x$1 >= 1e21 || x$1.toFixed().length > prec$1) {
	            var i$1 = j - 1 | 0;
	            while(s[i$1] === "0") {
	              i$1 = i$1 - 1 | 0;
	            };
	            if (s[i$1] === ".") {
	              i$1 = i$1 - 1 | 0;
	            }
	            s = s.slice(0, i$1 + 1 | 0) + s.slice(j);
	            var i$2 = s.length;
	            if (s[i$2 - 3 | 0] === "e") {
	              s = s.slice(0, i$2 - 1 | 0) + ("0" + s.slice(i$2 - 1 | 0));
	            }
	            
	          } else {
	            var p = prec$1;
	            if (exp < 0) {
	              p = p - (exp + 1 | 0) | 0;
	              s = x$1.toFixed(p);
	            } else {
	              while((function () {
	                      s = x$1.toFixed(p);
	                      return +(s.length > (prec$1 + 1 | 0));
	                    })()) {
	                p = p - 1 | 0;
	              };
	            }
	            if (p !== 0) {
	              var k = s.length - 1 | 0;
	              while(s[k] === "0") {
	                k = k - 1 | 0;
	              };
	              if (s[k] === ".") {
	                k = k - 1 | 0;
	              }
	              s = s.slice(0, k + 1 | 0);
	            }
	            
	          }
	          break;
	      default:
	        
	    }
	  } else {
	    s = "inf";
	    f[/* filter */2] = " ";
	  }
	  return finish_formatting(f, s);
	}

	var float_of_string = (
	  function (s, caml_failwith) {
	    var res = +s;
	    if ((s.length > 0) && (res === res))
	        return res;
	    s = s.replace(/_/g, "");
	    res = +s;
	    if (((s.length > 0) && (res === res)) || /^[+-]?nan$/i.test(s)) {
	        return res;
	    }
	    ;
	    if (/^ *0x[0-9a-f_]+p[+-]?[0-9_]+/i.test(s)) {
	        var pidx = s.indexOf('p');
	        pidx = (pidx == -1) ? s.indexOf('P') : pidx;
	        var exp = +s.substring(pidx + 1);
	        res = +s.substring(0, pidx);
	        return res * Math.pow(2, exp);
	    }
	    if (/^\+?inf(inity)?$/i.test(s))
	        return Infinity;
	    if (/^-inf(inity)?$/i.test(s))
	        return -Infinity;
	    caml_failwith("float_of_string");
	}

	);

	function caml_float_of_string(s) {
	  return Curry._2(float_of_string, s, caml_failwith);
	}

	var caml_nativeint_format = caml_format_int;

	var caml_int32_format = caml_format_int;

	var caml_int32_of_string = caml_int_of_string;

	var caml_nativeint_of_string = caml_int_of_string;

	exports.caml_format_float        = caml_format_float;
	exports.caml_format_int          = caml_format_int;
	exports.caml_nativeint_format    = caml_nativeint_format;
	exports.caml_int32_format        = caml_int32_format;
	exports.caml_float_of_string     = caml_float_of_string;
	exports.caml_int64_format        = caml_int64_format;
	exports.caml_int_of_string       = caml_int_of_string;
	exports.caml_int32_of_string     = caml_int32_of_string;
	exports.caml_int64_of_string     = caml_int64_of_string;
	exports.caml_nativeint_of_string = caml_nativeint_of_string;
	/* float_of_string Not a pure module */


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var Caml_builtin_exceptions = __webpack_require__(5);

	function div(x, y) {
	  if (y === 0) {
	    throw Caml_builtin_exceptions.division_by_zero;
	  } else {
	    return x / y | 0;
	  }
	}

	function mod_(x, y) {
	  if (y === 0) {
	    throw Caml_builtin_exceptions.division_by_zero;
	  } else {
	    return x % y;
	  }
	}

	function caml_bswap16(x) {
	  return ((x & 255) << 8) | ((x & 65280) >>> 8);
	}

	function caml_int32_bswap(x) {
	  return ((x & 255) << 24) | ((x & 65280) << 8) | ((x & 16711680) >>> 8) | ((x & 4278190080) >>> 24);
	}

	var imul = ( Math.imul || function (x,y) {
	  y |= 0; return ((((x >> 16) * y) << 16) + (x & 0xffff) * y)|0; 
	}
	);

	var caml_nativeint_bswap = caml_int32_bswap;

	exports.div                  = div;
	exports.mod_                 = mod_;
	exports.caml_bswap16         = caml_bswap16;
	exports.caml_int32_bswap     = caml_int32_bswap;
	exports.caml_nativeint_bswap = caml_nativeint_bswap;
	exports.imul                 = imul;
	/* imul Not a pure module */


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var Caml_obj                = __webpack_require__(6);
	var Caml_int32              = __webpack_require__(13);
	var Caml_utils              = __webpack_require__(15);
	var Caml_builtin_exceptions = __webpack_require__(5);

	var min_int = /* record */[
	  /* hi */-2147483648,
	  /* lo */0
	];

	var max_int = /* record */[
	  /* hi */134217727,
	  /* lo */1
	];

	var one = /* record */[
	  /* hi */0,
	  /* lo */1
	];

	var zero = /* record */[
	  /* hi */0,
	  /* lo */0
	];

	var neg_one = /* record */[
	  /* hi */-1,
	  /* lo */4294967295
	];

	function neg_signed(x) {
	  return +((x & 2147483648) !== 0);
	}

	function add(param, param$1) {
	  var other_low_ = param$1[/* lo */1];
	  var this_low_ = param[/* lo */1];
	  var lo = this_low_ + other_low_ & 4294967295;
	  var overflow = neg_signed(this_low_) && (neg_signed(other_low_) || !neg_signed(lo)) || neg_signed(other_low_) && !neg_signed(lo) ? 1 : 0;
	  var hi = param[/* hi */0] + param$1[/* hi */0] + overflow & 4294967295;
	  return /* record */[
	          /* hi */hi,
	          /* lo */(lo >>> 0)
	        ];
	}

	function not(param) {
	  var hi = param[/* hi */0] ^ -1;
	  var lo = param[/* lo */1] ^ -1;
	  return /* record */[
	          /* hi */hi,
	          /* lo */(lo >>> 0)
	        ];
	}

	function eq(x, y) {
	  if (x[/* hi */0] === y[/* hi */0]) {
	    return +(x[/* lo */1] === y[/* lo */1]);
	  } else {
	    return /* false */0;
	  }
	}

	function neg(x) {
	  if (eq(x, min_int)) {
	    return min_int;
	  } else {
	    return add(not(x), one);
	  }
	}

	function sub(x, y) {
	  return add(x, neg(y));
	}

	function lsl_(x, numBits) {
	  if (numBits) {
	    var lo = x[/* lo */1];
	    if (numBits >= 32) {
	      return /* record */[
	              /* hi */(lo << (numBits - 32 | 0)),
	              /* lo */0
	            ];
	    } else {
	      var hi = (lo >>> (32 - numBits | 0)) | (x[/* hi */0] << numBits);
	      return /* record */[
	              /* hi */hi,
	              /* lo */((lo << numBits) >>> 0)
	            ];
	    }
	  } else {
	    return x;
	  }
	}

	function lsr_(x, numBits) {
	  if (numBits) {
	    var hi = x[/* hi */0];
	    var offset = numBits - 32 | 0;
	    if (offset) {
	      if (offset > 0) {
	        var lo = (hi >>> offset);
	        return /* record */[
	                /* hi */0,
	                /* lo */(lo >>> 0)
	              ];
	      } else {
	        var hi$1 = (hi >>> numBits);
	        var lo$1 = (hi << (-offset | 0)) | (x[/* lo */1] >>> numBits);
	        return /* record */[
	                /* hi */hi$1,
	                /* lo */(lo$1 >>> 0)
	              ];
	      }
	    } else {
	      return /* record */[
	              /* hi */0,
	              /* lo */(hi >>> 0)
	            ];
	    }
	  } else {
	    return x;
	  }
	}

	function asr_(x, numBits) {
	  if (numBits) {
	    var hi = x[/* hi */0];
	    if (numBits < 32) {
	      var hi$1 = (hi >> numBits);
	      var lo = (hi << (32 - numBits | 0)) | (x[/* lo */1] >>> numBits);
	      return /* record */[
	              /* hi */hi$1,
	              /* lo */(lo >>> 0)
	            ];
	    } else {
	      var lo$1 = (hi >> (numBits - 32 | 0));
	      return /* record */[
	              /* hi */hi >= 0 ? 0 : -1,
	              /* lo */(lo$1 >>> 0)
	            ];
	    }
	  } else {
	    return x;
	  }
	}

	function is_zero(param) {
	  if (param[/* hi */0] !== 0 || param[/* lo */1] !== 0) {
	    return /* false */0;
	  } else {
	    return /* true */1;
	  }
	}

	function mul(_this, _other) {
	  while(true) {
	    var other = _other;
	    var $$this = _this;
	    var exit = 0;
	    var lo;
	    var this_hi = $$this[/* hi */0];
	    var exit$1 = 0;
	    var exit$2 = 0;
	    var exit$3 = 0;
	    if (this_hi !== 0) {
	      exit$3 = 4;
	    } else if ($$this[/* lo */1] !== 0) {
	      exit$3 = 4;
	    } else {
	      return zero;
	    }
	    if (exit$3 === 4) {
	      if (other[/* hi */0] !== 0) {
	        exit$2 = 3;
	      } else if (other[/* lo */1] !== 0) {
	        exit$2 = 3;
	      } else {
	        return zero;
	      }
	    }
	    if (exit$2 === 3) {
	      if (this_hi !== -2147483648) {
	        exit$1 = 2;
	      } else if ($$this[/* lo */1] !== 0) {
	        exit$1 = 2;
	      } else {
	        lo = other[/* lo */1];
	        exit = 1;
	      }
	    }
	    if (exit$1 === 2) {
	      var other_hi = other[/* hi */0];
	      var lo$1 = $$this[/* lo */1];
	      var exit$4 = 0;
	      if (other_hi !== -2147483648) {
	        exit$4 = 3;
	      } else if (other[/* lo */1] !== 0) {
	        exit$4 = 3;
	      } else {
	        lo = lo$1;
	        exit = 1;
	      }
	      if (exit$4 === 3) {
	        var other_lo = other[/* lo */1];
	        if (this_hi < 0) {
	          if (other_hi < 0) {
	            _other = neg(other);
	            _this = neg($$this);
	            continue ;
	            
	          } else {
	            return neg(mul(neg($$this), other));
	          }
	        } else if (other_hi < 0) {
	          return neg(mul($$this, neg(other)));
	        } else {
	          var a48 = (this_hi >>> 16);
	          var a32 = this_hi & 65535;
	          var a16 = (lo$1 >>> 16);
	          var a00 = lo$1 & 65535;
	          var b48 = (other_hi >>> 16);
	          var b32 = other_hi & 65535;
	          var b16 = (other_lo >>> 16);
	          var b00 = other_lo & 65535;
	          var c48 = 0;
	          var c32 = 0;
	          var c16 = 0;
	          var c00 = a00 * b00;
	          c16 = (c00 >>> 16) + a16 * b00;
	          c32 = (c16 >>> 16);
	          c16 = (c16 & 65535) + a00 * b16;
	          c32 = c32 + (c16 >>> 16) + a32 * b00;
	          c48 = (c32 >>> 16);
	          c32 = (c32 & 65535) + a16 * b16;
	          c48 += (c32 >>> 16);
	          c32 = (c32 & 65535) + a00 * b32;
	          c48 += (c32 >>> 16);
	          c32 = c32 & 65535;
	          c48 = c48 + (a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48) & 65535;
	          var hi = c32 | (c48 << 16);
	          var lo$2 = c00 & 65535 | ((c16 & 65535) << 16);
	          return /* record */[
	                  /* hi */hi,
	                  /* lo */(lo$2 >>> 0)
	                ];
	        }
	      }
	      
	    }
	    if (exit === 1) {
	      if ((lo & 1) === 0) {
	        return zero;
	      } else {
	        return min_int;
	      }
	    }
	    
	  };
	}

	function swap(param) {
	  var hi = Caml_int32.caml_int32_bswap(param[/* lo */1]);
	  var lo = Caml_int32.caml_int32_bswap(param[/* hi */0]);
	  return /* record */[
	          /* hi */hi,
	          /* lo */(lo >>> 0)
	        ];
	}

	function xor(param, param$1) {
	  return /* record */[
	          /* hi */param[/* hi */0] ^ param$1[/* hi */0],
	          /* lo */((param[/* lo */1] ^ param$1[/* lo */1]) >>> 0)
	        ];
	}

	function or_(param, param$1) {
	  return /* record */[
	          /* hi */param[/* hi */0] | param$1[/* hi */0],
	          /* lo */((param[/* lo */1] | param$1[/* lo */1]) >>> 0)
	        ];
	}

	function and_(param, param$1) {
	  return /* record */[
	          /* hi */param[/* hi */0] & param$1[/* hi */0],
	          /* lo */((param[/* lo */1] & param$1[/* lo */1]) >>> 0)
	        ];
	}

	function ge(param, param$1) {
	  var other_hi = param$1[/* hi */0];
	  var hi = param[/* hi */0];
	  if (hi > other_hi) {
	    return /* true */1;
	  } else if (hi < other_hi) {
	    return /* false */0;
	  } else {
	    return +(param[/* lo */1] >= param$1[/* lo */1]);
	  }
	}

	function neq(x, y) {
	  return 1 - eq(x, y);
	}

	function lt(x, y) {
	  return 1 - ge(x, y);
	}

	function gt(x, y) {
	  if (x[/* hi */0] > y[/* hi */0]) {
	    return /* true */1;
	  } else if (x[/* hi */0] < y[/* hi */0]) {
	    return /* false */0;
	  } else {
	    return +(x[/* lo */1] > y[/* lo */1]);
	  }
	}

	function le(x, y) {
	  return 1 - gt(x, y);
	}

	function to_float(param) {
	  return param[/* hi */0] * (0x100000000) + param[/* lo */1];
	}

	var two_ptr_32_dbl = Math.pow(2, 32);

	var two_ptr_63_dbl = Math.pow(2, 63);

	var neg_two_ptr_63 = -Math.pow(2, 63);

	function of_float(x) {
	  if (isNaN(x) || !isFinite(x)) {
	    return zero;
	  } else if (x <= neg_two_ptr_63) {
	    return min_int;
	  } else if (x + 1 >= two_ptr_63_dbl) {
	    return max_int;
	  } else if (x < 0) {
	    return neg(of_float(-x));
	  } else {
	    var hi = x / two_ptr_32_dbl | 0;
	    var lo = x % two_ptr_32_dbl | 0;
	    return /* record */[
	            /* hi */hi,
	            /* lo */(lo >>> 0)
	          ];
	  }
	}

	function div(_self, _other) {
	  while(true) {
	    var other = _other;
	    var self = _self;
	    var self_hi = self[/* hi */0];
	    var exit = 0;
	    var exit$1 = 0;
	    if (other[/* hi */0] !== 0) {
	      exit$1 = 2;
	    } else if (other[/* lo */1] !== 0) {
	      exit$1 = 2;
	    } else {
	      throw Caml_builtin_exceptions.division_by_zero;
	    }
	    if (exit$1 === 2) {
	      if (self_hi !== -2147483648) {
	        if (self_hi !== 0) {
	          exit = 1;
	        } else if (self[/* lo */1] !== 0) {
	          exit = 1;
	        } else {
	          return zero;
	        }
	      } else if (self[/* lo */1] !== 0) {
	        exit = 1;
	      } else if (eq(other, one) || eq(other, neg_one)) {
	        return self;
	      } else if (eq(other, min_int)) {
	        return one;
	      } else {
	        var other_hi = other[/* hi */0];
	        var half_this = asr_(self, 1);
	        var approx = lsl_(div(half_this, other), 1);
	        var exit$2 = 0;
	        if (approx[/* hi */0] !== 0) {
	          exit$2 = 3;
	        } else if (approx[/* lo */1] !== 0) {
	          exit$2 = 3;
	        } else if (other_hi < 0) {
	          return one;
	        } else {
	          return neg(one);
	        }
	        if (exit$2 === 3) {
	          var y = mul(other, approx);
	          var rem = add(self, neg(y));
	          return add(approx, div(rem, other));
	        }
	        
	      }
	    }
	    if (exit === 1) {
	      var other_hi$1 = other[/* hi */0];
	      var exit$3 = 0;
	      if (other_hi$1 !== -2147483648) {
	        exit$3 = 2;
	      } else if (other[/* lo */1] !== 0) {
	        exit$3 = 2;
	      } else {
	        return zero;
	      }
	      if (exit$3 === 2) {
	        if (self_hi < 0) {
	          if (other_hi$1 < 0) {
	            _other = neg(other);
	            _self = neg(self);
	            continue ;
	            
	          } else {
	            return neg(div(neg(self), other));
	          }
	        } else if (other_hi$1 < 0) {
	          return neg(div(self, neg(other)));
	        } else {
	          var res = zero;
	          var rem$1 = self;
	          while(ge(rem$1, other)) {
	            var approx$1 = Math.max(1, Math.floor(to_float(rem$1) / to_float(other)));
	            var log2 = Math.ceil(Math.log(approx$1) / Math.LN2);
	            var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
	            var approxRes = of_float(approx$1);
	            var approxRem = mul(approxRes, other);
	            while(approxRem[/* hi */0] < 0 || gt(approxRem, rem$1)) {
	              approx$1 -= delta;
	              approxRes = of_float(approx$1);
	              approxRem = mul(approxRes, other);
	            };
	            if (is_zero(approxRes)) {
	              approxRes = one;
	            }
	            res = add(res, approxRes);
	            rem$1 = add(rem$1, neg(approxRem));
	          };
	          return res;
	        }
	      }
	      
	    }
	    
	  };
	}

	function mod_(self, other) {
	  var y = mul(div(self, other), other);
	  return add(self, neg(y));
	}

	function div_mod(self, other) {
	  var quotient = div(self, other);
	  var y = mul(quotient, other);
	  return /* tuple */[
	          quotient,
	          add(self, neg(y))
	        ];
	}

	function compare(self, other) {
	  var v = Caml_obj.caml_nativeint_compare(self[/* hi */0], other[/* hi */0]);
	  if (v) {
	    return v;
	  } else {
	    return Caml_obj.caml_nativeint_compare(self[/* lo */1], other[/* lo */1]);
	  }
	}

	function of_int32(lo) {
	  return /* record */[
	          /* hi */lo < 0 ? -1 : 0,
	          /* lo */(lo >>> 0)
	        ];
	}

	function to_int32(x) {
	  return x[/* lo */1] | 0;
	}

	function to_hex(x) {
	  var aux = function (v) {
	    return (v >>> 0).toString(16);
	  };
	  var match = x[/* hi */0];
	  var match$1 = x[/* lo */1];
	  var exit = 0;
	  if (match !== 0) {
	    exit = 1;
	  } else if (match$1 !== 0) {
	    exit = 1;
	  } else {
	    return "0";
	  }
	  if (exit === 1) {
	    if (match$1 !== 0) {
	      if (match !== 0) {
	        var lo = aux(x[/* lo */1]);
	        var pad = 8 - lo.length | 0;
	        if (pad <= 0) {
	          return aux(x[/* hi */0]) + lo;
	        } else {
	          return aux(x[/* hi */0]) + (Caml_utils.repeat(pad, "0") + lo);
	        }
	      } else {
	        return aux(x[/* lo */1]);
	      }
	    } else {
	      return aux(x[/* hi */0]) + "00000000";
	    }
	  }
	  
	}

	function discard_sign(x) {
	  return /* record */[
	          /* hi */2147483647 & x[/* hi */0],
	          /* lo */x[/* lo */1]
	        ];
	}

	function float_of_bits(x) {
	  var int32 = new Int32Array(/* array */[
	        x[/* lo */1],
	        x[/* hi */0]
	      ]);
	  return new Float64Array(int32.buffer)[0];
	}

	function bits_of_float(x) {
	  var u = new Float64Array(/* float array */[x]);
	  var int32 = new Int32Array(u.buffer);
	  var x$1 = int32[1];
	  var hi = x$1;
	  var x$2 = int32[0];
	  var lo = x$2;
	  return /* record */[
	          /* hi */hi,
	          /* lo */(lo >>> 0)
	        ];
	}

	function get64(s, i) {
	  var hi = (s.charCodeAt(i + 4 | 0) << 32) | (s.charCodeAt(i + 5 | 0) << 40) | (s.charCodeAt(i + 6 | 0) << 48) | (s.charCodeAt(i + 7 | 0) << 56);
	  var lo = s.charCodeAt(i) | (s.charCodeAt(i + 1 | 0) << 8) | (s.charCodeAt(i + 2 | 0) << 16) | (s.charCodeAt(i + 3 | 0) << 24);
	  return /* record */[
	          /* hi */hi,
	          /* lo */(lo >>> 0)
	        ];
	}

	exports.min_int       = min_int;
	exports.max_int       = max_int;
	exports.one           = one;
	exports.zero          = zero;
	exports.not           = not;
	exports.of_int32      = of_int32;
	exports.to_int32      = to_int32;
	exports.add           = add;
	exports.neg           = neg;
	exports.sub           = sub;
	exports.lsl_          = lsl_;
	exports.lsr_          = lsr_;
	exports.asr_          = asr_;
	exports.is_zero       = is_zero;
	exports.mul           = mul;
	exports.xor           = xor;
	exports.or_           = or_;
	exports.and_          = and_;
	exports.swap          = swap;
	exports.ge            = ge;
	exports.eq            = eq;
	exports.neq           = neq;
	exports.lt            = lt;
	exports.gt            = gt;
	exports.le            = le;
	exports.to_float      = to_float;
	exports.of_float      = of_float;
	exports.div           = div;
	exports.mod_          = mod_;
	exports.div_mod       = div_mod;
	exports.compare       = compare;
	exports.to_hex        = to_hex;
	exports.discard_sign  = discard_sign;
	exports.float_of_bits = float_of_bits;
	exports.bits_of_float = bits_of_float;
	exports.get64         = get64;
	/* two_ptr_32_dbl Not a pure module */


/***/ }),
/* 15 */
/***/ (function(module, exports) {

	'use strict';


	var repeat = ( (String.prototype.repeat && function (count,self){return self.repeat(count)}) ||
	                                                  function(count , self) {
	        if (self.length == 0 || count == 0) {
	            return '';
	        }
	        // Ensuring count is a 31-bit integer allows us to heavily optimize the
	        // main part. But anyway, most current (August 2014) browsers can't handle
	        // strings 1 << 28 chars or longer, so:
	        if (self.length * count >= 1 << 28) {
	            throw new RangeError('repeat count must not overflow maximum string size');
	        }
	        var rpt = '';
	        for (;;) {
	            if ((count & 1) == 1) {
	                rpt += self;
	            }
	            count >>>= 1;
	            if (count == 0) {
	                break;
	            }
	            self += self;
	        }
	        return rpt;
	    }
	);

	exports.repeat = repeat;
	/* repeat Not a pure module */


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var Caml_builtin_exceptions = __webpack_require__(5);

	function string_of_char(prim) {
	  return String.fromCharCode(prim);
	}

	function caml_string_get(s, i) {
	  if (i >= s.length || i < 0) {
	    throw [
	          Caml_builtin_exceptions.invalid_argument,
	          "index out of bounds"
	        ];
	  } else {
	    return s.charCodeAt(i);
	  }
	}

	function caml_create_string(len) {
	  if (len < 0) {
	    throw [
	          Caml_builtin_exceptions.invalid_argument,
	          "String.create"
	        ];
	  } else {
	    return new Array(len);
	  }
	}

	function caml_string_compare(s1, s2) {
	  if (s1 === s2) {
	    return 0;
	  } else if (s1 < s2) {
	    return -1;
	  } else {
	    return 1;
	  }
	}

	function caml_fill_string(s, i, l, c) {
	  if (l > 0) {
	    for(var k = i ,k_finish = (l + i | 0) - 1 | 0; k <= k_finish; ++k){
	      s[k] = c;
	    }
	    return /* () */0;
	  } else {
	    return 0;
	  }
	}

	function caml_blit_string(s1, i1, s2, i2, len) {
	  if (len > 0) {
	    var off1 = s1.length - i1 | 0;
	    if (len <= off1) {
	      for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
	        s2[i2 + i | 0] = s1.charCodeAt(i1 + i | 0);
	      }
	      return /* () */0;
	    } else {
	      for(var i$1 = 0 ,i_finish$1 = off1 - 1 | 0; i$1 <= i_finish$1; ++i$1){
	        s2[i2 + i$1 | 0] = s1.charCodeAt(i1 + i$1 | 0);
	      }
	      for(var i$2 = off1 ,i_finish$2 = len - 1 | 0; i$2 <= i_finish$2; ++i$2){
	        s2[i2 + i$2 | 0] = /* "\000" */0;
	      }
	      return /* () */0;
	    }
	  } else {
	    return 0;
	  }
	}

	function caml_blit_bytes(s1, i1, s2, i2, len) {
	  if (len > 0) {
	    if (s1 === s2) {
	      var s1$1 = s1;
	      var i1$1 = i1;
	      var i2$1 = i2;
	      var len$1 = len;
	      if (i1$1 < i2$1) {
	        var range_a = (s1$1.length - i2$1 | 0) - 1 | 0;
	        var range_b = len$1 - 1 | 0;
	        var range = range_a > range_b ? range_b : range_a;
	        for(var j = range; j >= 0; --j){
	          s1$1[i2$1 + j | 0] = s1$1[i1$1 + j | 0];
	        }
	        return /* () */0;
	      } else if (i1$1 > i2$1) {
	        var range_a$1 = (s1$1.length - i1$1 | 0) - 1 | 0;
	        var range_b$1 = len$1 - 1 | 0;
	        var range$1 = range_a$1 > range_b$1 ? range_b$1 : range_a$1;
	        for(var k = 0; k <= range$1; ++k){
	          s1$1[i2$1 + k | 0] = s1$1[i1$1 + k | 0];
	        }
	        return /* () */0;
	      } else {
	        return 0;
	      }
	    } else {
	      var off1 = s1.length - i1 | 0;
	      if (len <= off1) {
	        for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
	          s2[i2 + i | 0] = s1[i1 + i | 0];
	        }
	        return /* () */0;
	      } else {
	        for(var i$1 = 0 ,i_finish$1 = off1 - 1 | 0; i$1 <= i_finish$1; ++i$1){
	          s2[i2 + i$1 | 0] = s1[i1 + i$1 | 0];
	        }
	        for(var i$2 = off1 ,i_finish$2 = len - 1 | 0; i$2 <= i_finish$2; ++i$2){
	          s2[i2 + i$2 | 0] = /* "\000" */0;
	        }
	        return /* () */0;
	      }
	    }
	  } else {
	    return 0;
	  }
	}

	function bytes_of_string(s) {
	  var len = s.length;
	  var res = new Array(len);
	  for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
	    res[i] = s.charCodeAt(i);
	  }
	  return res;
	}

	function bytes_to_string(a) {
	  var bytes = a;
	  var i = 0;
	  var len = a.length;
	  var s = "";
	  var s_len = len;
	  if (i === 0 && len <= 4096 && len === bytes.length) {
	    return String.fromCharCode.apply(null,bytes);
	  } else {
	    var offset = 0;
	    while(s_len > 0) {
	      var next = s_len < 1024 ? s_len : 1024;
	      var tmp_bytes = new Array(next);
	      caml_blit_bytes(bytes, offset, tmp_bytes, 0, next);
	      s = s + String.fromCharCode.apply(null,tmp_bytes);
	      s_len = s_len - next | 0;
	      offset = offset + next | 0;
	    };
	    return s;
	  }
	}

	function caml_string_of_char_array(chars) {
	  var len = chars.length;
	  var bytes = new Array(len);
	  for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
	    bytes[i] = chars[i];
	  }
	  return bytes_to_string(bytes);
	}

	function caml_is_printable(c) {
	  if (c > 31) {
	    return +(c < 127);
	  } else {
	    return /* false */0;
	  }
	}

	function caml_string_get16(s, i) {
	  return s.charCodeAt(i) + (s.charCodeAt(i + 1 | 0) << 8) | 0;
	}

	function caml_string_get32(s, i) {
	  return ((s.charCodeAt(i) + (s.charCodeAt(i + 1 | 0) << 8) | 0) + (s.charCodeAt(i + 2 | 0) << 16) | 0) + (s.charCodeAt(i + 3 | 0) << 24) | 0;
	}

	function get(s, i) {
	  if (i < 0 || i >= s.length) {
	    throw [
	          Caml_builtin_exceptions.invalid_argument,
	          "index out of bounds"
	        ];
	  } else {
	    return s.charCodeAt(i);
	  }
	}

	exports.bytes_of_string           = bytes_of_string;
	exports.bytes_to_string           = bytes_to_string;
	exports.caml_is_printable         = caml_is_printable;
	exports.caml_string_of_char_array = caml_string_of_char_array;
	exports.caml_string_get           = caml_string_get;
	exports.caml_string_compare       = caml_string_compare;
	exports.caml_create_string        = caml_create_string;
	exports.caml_fill_string          = caml_fill_string;
	exports.caml_blit_string          = caml_blit_string;
	exports.caml_blit_bytes           = caml_blit_bytes;
	exports.caml_string_get16         = caml_string_get16;
	exports.caml_string_get32         = caml_string_get32;
	exports.string_of_char            = string_of_char;
	exports.get                       = get;
	/* No side effect */


/***/ }),
/* 17 */
/***/ (function(module, exports) {

	'use strict';


	var id = [0];

	function caml_set_oo_id(b) {
	  b[1] = id[0];
	  id[0] += 1;
	  return b;
	}

	function get_id() {
	  id[0] += 1;
	  return id[0];
	}

	function create(str) {
	  var v_001 = get_id(/* () */0);
	  var v = /* tuple */[
	    str,
	    v_001
	  ];
	  v.tag = 248;
	  return v;
	}

	function isCamlExceptionOrOpenVariant(e) {
	  if (e === undefined) {
	    return /* false */0;
	  } else if (e.tag === 248) {
	    return /* true */1;
	  } else {
	    var slot = e[0];
	    if (slot !== undefined) {
	      return +(slot.tag === 248);
	    } else {
	      return /* false */0;
	    }
	  }
	}

	exports.caml_set_oo_id               = caml_set_oo_id;
	exports.get_id                       = get_id;
	exports.create                       = create;
	exports.isCamlExceptionOrOpenVariant = isCamlExceptionOrOpenVariant;
	/* No side effect */


/***/ }),
/* 18 */
/***/ (function(module, exports) {

	'use strict';


	var not_implemented = (function (s){ throw new Error(s)});

	exports.not_implemented = not_implemented;
	/* not_implemented Not a pure module */


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var Block = __webpack_require__(7);

	function erase_rel(param) {
	  if (typeof param === "number") {
	    return /* End_of_fmtty */0;
	  } else {
	    switch (param.tag | 0) {
	      case 0 : 
	          return /* Char_ty */Block.__(0, [erase_rel(param[0])]);
	      case 1 : 
	          return /* String_ty */Block.__(1, [erase_rel(param[0])]);
	      case 2 : 
	          return /* Int_ty */Block.__(2, [erase_rel(param[0])]);
	      case 3 : 
	          return /* Int32_ty */Block.__(3, [erase_rel(param[0])]);
	      case 4 : 
	          return /* Nativeint_ty */Block.__(4, [erase_rel(param[0])]);
	      case 5 : 
	          return /* Int64_ty */Block.__(5, [erase_rel(param[0])]);
	      case 6 : 
	          return /* Float_ty */Block.__(6, [erase_rel(param[0])]);
	      case 7 : 
	          return /* Bool_ty */Block.__(7, [erase_rel(param[0])]);
	      case 8 : 
	          return /* Format_arg_ty */Block.__(8, [
	                    param[0],
	                    erase_rel(param[1])
	                  ]);
	      case 9 : 
	          var ty1 = param[0];
	          return /* Format_subst_ty */Block.__(9, [
	                    ty1,
	                    ty1,
	                    erase_rel(param[2])
	                  ]);
	      case 10 : 
	          return /* Alpha_ty */Block.__(10, [erase_rel(param[0])]);
	      case 11 : 
	          return /* Theta_ty */Block.__(11, [erase_rel(param[0])]);
	      case 12 : 
	          return /* Any_ty */Block.__(12, [erase_rel(param[0])]);
	      case 13 : 
	          return /* Reader_ty */Block.__(13, [erase_rel(param[0])]);
	      case 14 : 
	          return /* Ignored_reader_ty */Block.__(14, [erase_rel(param[0])]);
	      
	    }
	  }
	}

	function concat_fmtty(fmtty1, fmtty2) {
	  if (typeof fmtty1 === "number") {
	    return fmtty2;
	  } else {
	    switch (fmtty1.tag | 0) {
	      case 0 : 
	          return /* Char_ty */Block.__(0, [concat_fmtty(fmtty1[0], fmtty2)]);
	      case 1 : 
	          return /* String_ty */Block.__(1, [concat_fmtty(fmtty1[0], fmtty2)]);
	      case 2 : 
	          return /* Int_ty */Block.__(2, [concat_fmtty(fmtty1[0], fmtty2)]);
	      case 3 : 
	          return /* Int32_ty */Block.__(3, [concat_fmtty(fmtty1[0], fmtty2)]);
	      case 4 : 
	          return /* Nativeint_ty */Block.__(4, [concat_fmtty(fmtty1[0], fmtty2)]);
	      case 5 : 
	          return /* Int64_ty */Block.__(5, [concat_fmtty(fmtty1[0], fmtty2)]);
	      case 6 : 
	          return /* Float_ty */Block.__(6, [concat_fmtty(fmtty1[0], fmtty2)]);
	      case 7 : 
	          return /* Bool_ty */Block.__(7, [concat_fmtty(fmtty1[0], fmtty2)]);
	      case 8 : 
	          return /* Format_arg_ty */Block.__(8, [
	                    fmtty1[0],
	                    concat_fmtty(fmtty1[1], fmtty2)
	                  ]);
	      case 9 : 
	          return /* Format_subst_ty */Block.__(9, [
	                    fmtty1[0],
	                    fmtty1[1],
	                    concat_fmtty(fmtty1[2], fmtty2)
	                  ]);
	      case 10 : 
	          return /* Alpha_ty */Block.__(10, [concat_fmtty(fmtty1[0], fmtty2)]);
	      case 11 : 
	          return /* Theta_ty */Block.__(11, [concat_fmtty(fmtty1[0], fmtty2)]);
	      case 12 : 
	          return /* Any_ty */Block.__(12, [concat_fmtty(fmtty1[0], fmtty2)]);
	      case 13 : 
	          return /* Reader_ty */Block.__(13, [concat_fmtty(fmtty1[0], fmtty2)]);
	      case 14 : 
	          return /* Ignored_reader_ty */Block.__(14, [concat_fmtty(fmtty1[0], fmtty2)]);
	      
	    }
	  }
	}

	function concat_fmt(fmt1, fmt2) {
	  if (typeof fmt1 === "number") {
	    return fmt2;
	  } else {
	    switch (fmt1.tag | 0) {
	      case 0 : 
	          return /* Char */Block.__(0, [concat_fmt(fmt1[0], fmt2)]);
	      case 1 : 
	          return /* Caml_char */Block.__(1, [concat_fmt(fmt1[0], fmt2)]);
	      case 2 : 
	          return /* String */Block.__(2, [
	                    fmt1[0],
	                    concat_fmt(fmt1[1], fmt2)
	                  ]);
	      case 3 : 
	          return /* Caml_string */Block.__(3, [
	                    fmt1[0],
	                    concat_fmt(fmt1[1], fmt2)
	                  ]);
	      case 4 : 
	          return /* Int */Block.__(4, [
	                    fmt1[0],
	                    fmt1[1],
	                    fmt1[2],
	                    concat_fmt(fmt1[3], fmt2)
	                  ]);
	      case 5 : 
	          return /* Int32 */Block.__(5, [
	                    fmt1[0],
	                    fmt1[1],
	                    fmt1[2],
	                    concat_fmt(fmt1[3], fmt2)
	                  ]);
	      case 6 : 
	          return /* Nativeint */Block.__(6, [
	                    fmt1[0],
	                    fmt1[1],
	                    fmt1[2],
	                    concat_fmt(fmt1[3], fmt2)
	                  ]);
	      case 7 : 
	          return /* Int64 */Block.__(7, [
	                    fmt1[0],
	                    fmt1[1],
	                    fmt1[2],
	                    concat_fmt(fmt1[3], fmt2)
	                  ]);
	      case 8 : 
	          return /* Float */Block.__(8, [
	                    fmt1[0],
	                    fmt1[1],
	                    fmt1[2],
	                    concat_fmt(fmt1[3], fmt2)
	                  ]);
	      case 9 : 
	          return /* Bool */Block.__(9, [concat_fmt(fmt1[0], fmt2)]);
	      case 10 : 
	          return /* Flush */Block.__(10, [concat_fmt(fmt1[0], fmt2)]);
	      case 11 : 
	          return /* String_literal */Block.__(11, [
	                    fmt1[0],
	                    concat_fmt(fmt1[1], fmt2)
	                  ]);
	      case 12 : 
	          return /* Char_literal */Block.__(12, [
	                    fmt1[0],
	                    concat_fmt(fmt1[1], fmt2)
	                  ]);
	      case 13 : 
	          return /* Format_arg */Block.__(13, [
	                    fmt1[0],
	                    fmt1[1],
	                    concat_fmt(fmt1[2], fmt2)
	                  ]);
	      case 14 : 
	          return /* Format_subst */Block.__(14, [
	                    fmt1[0],
	                    fmt1[1],
	                    concat_fmt(fmt1[2], fmt2)
	                  ]);
	      case 15 : 
	          return /* Alpha */Block.__(15, [concat_fmt(fmt1[0], fmt2)]);
	      case 16 : 
	          return /* Theta */Block.__(16, [concat_fmt(fmt1[0], fmt2)]);
	      case 17 : 
	          return /* Formatting_lit */Block.__(17, [
	                    fmt1[0],
	                    concat_fmt(fmt1[1], fmt2)
	                  ]);
	      case 18 : 
	          return /* Formatting_gen */Block.__(18, [
	                    fmt1[0],
	                    concat_fmt(fmt1[1], fmt2)
	                  ]);
	      case 19 : 
	          return /* Reader */Block.__(19, [concat_fmt(fmt1[0], fmt2)]);
	      case 20 : 
	          return /* Scan_char_set */Block.__(20, [
	                    fmt1[0],
	                    fmt1[1],
	                    concat_fmt(fmt1[2], fmt2)
	                  ]);
	      case 21 : 
	          return /* Scan_get_counter */Block.__(21, [
	                    fmt1[0],
	                    concat_fmt(fmt1[1], fmt2)
	                  ]);
	      case 22 : 
	          return /* Scan_next_char */Block.__(22, [concat_fmt(fmt1[0], fmt2)]);
	      case 23 : 
	          return /* Ignored_param */Block.__(23, [
	                    fmt1[0],
	                    concat_fmt(fmt1[1], fmt2)
	                  ]);
	      case 24 : 
	          return /* Custom */Block.__(24, [
	                    fmt1[0],
	                    fmt1[1],
	                    concat_fmt(fmt1[2], fmt2)
	                  ]);
	      
	    }
	  }
	}

	exports.concat_fmtty = concat_fmtty;
	exports.erase_rel    = erase_rel;
	exports.concat_fmt   = concat_fmt;
	/* No side effect */


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var Caml_exceptions = __webpack_require__(17);

	var $$Error = Caml_exceptions.create("Js_exn.Error");

	function internalToOCamlException(e) {
	  if (Caml_exceptions.isCamlExceptionOrOpenVariant(e)) {
	    return e;
	  } else {
	    return [
	            $$Error,
	            e
	          ];
	  }
	}

	function raiseError(str) {
	  throw new Error(str);
	}

	function raiseEvalError(str) {
	  throw new EvalError(str);
	}

	function raiseRangeError(str) {
	  throw new RangeError(str);
	}

	function raiseReferenceError(str) {
	  throw new ReferenceError(str);
	}

	function raiseSyntaxError(str) {
	  throw new SyntaxError(str);
	}

	function raiseTypeError(str) {
	  throw new TypeError(str);
	}

	function raiseUriError(str) {
	  throw new URIError(str);
	}

	exports.$$Error                  = $$Error;
	exports.internalToOCamlException = internalToOCamlException;
	exports.raiseError               = raiseError;
	exports.raiseEvalError           = raiseEvalError;
	exports.raiseRangeError          = raiseRangeError;
	exports.raiseReferenceError      = raiseReferenceError;
	exports.raiseSyntaxError         = raiseSyntaxError;
	exports.raiseTypeError           = raiseTypeError;
	exports.raiseUriError            = raiseUriError;
	/* No side effect */


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var List        = __webpack_require__(2);
	var Bytes       = __webpack_require__(22);
	var Caml_int32  = __webpack_require__(13);
	var Caml_string = __webpack_require__(16);

	function make(n, c) {
	  return Caml_string.bytes_to_string(Bytes.make(n, c));
	}

	function init(n, f) {
	  return Caml_string.bytes_to_string(Bytes.init(n, f));
	}

	function copy(s) {
	  return Caml_string.bytes_to_string(Bytes.copy(Caml_string.bytes_of_string(s)));
	}

	function sub(s, ofs, len) {
	  return Caml_string.bytes_to_string(Bytes.sub(Caml_string.bytes_of_string(s), ofs, len));
	}

	function concat(sep, l) {
	  if (l) {
	    var hd = l[0];
	    var num = [0];
	    var len = [0];
	    List.iter((function (s) {
	            num[0] = num[0] + 1 | 0;
	            len[0] = len[0] + s.length | 0;
	            return /* () */0;
	          }), l);
	    var r = Caml_string.caml_create_string(len[0] + Caml_int32.imul(sep.length, num[0] - 1 | 0) | 0);
	    Caml_string.caml_blit_string(hd, 0, r, 0, hd.length);
	    var pos = [hd.length];
	    List.iter((function (s) {
	            Caml_string.caml_blit_string(sep, 0, r, pos[0], sep.length);
	            pos[0] = pos[0] + sep.length | 0;
	            Caml_string.caml_blit_string(s, 0, r, pos[0], s.length);
	            pos[0] = pos[0] + s.length | 0;
	            return /* () */0;
	          }), l[1]);
	    return Caml_string.bytes_to_string(r);
	  } else {
	    return "";
	  }
	}

	function iter(f, s) {
	  return Bytes.iter(f, Caml_string.bytes_of_string(s));
	}

	function iteri(f, s) {
	  return Bytes.iteri(f, Caml_string.bytes_of_string(s));
	}

	function map(f, s) {
	  return Caml_string.bytes_to_string(Bytes.map(f, Caml_string.bytes_of_string(s)));
	}

	function mapi(f, s) {
	  return Caml_string.bytes_to_string(Bytes.mapi(f, Caml_string.bytes_of_string(s)));
	}

	function is_space(param) {
	  var switcher = param - 9 | 0;
	  if (switcher > 4 || switcher < 0) {
	    if (switcher !== 23) {
	      return /* false */0;
	    } else {
	      return /* true */1;
	    }
	  } else if (switcher !== 2) {
	    return /* true */1;
	  } else {
	    return /* false */0;
	  }
	}

	function trim(s) {
	  if (s === "" || !(is_space(s.charCodeAt(0)) || is_space(s.charCodeAt(s.length - 1 | 0)))) {
	    return s;
	  } else {
	    return Caml_string.bytes_to_string(Bytes.trim(Caml_string.bytes_of_string(s)));
	  }
	}

	function escaped(s) {
	  var needs_escape = function (_i) {
	    while(true) {
	      var i = _i;
	      if (i >= s.length) {
	        return /* false */0;
	      } else {
	        var match = s.charCodeAt(i);
	        if (match >= 32) {
	          var switcher = match - 34 | 0;
	          if (switcher > 58 || switcher < 0) {
	            if (switcher >= 93) {
	              return /* true */1;
	            } else {
	              _i = i + 1 | 0;
	              continue ;
	              
	            }
	          } else if (switcher > 57 || switcher < 1) {
	            return /* true */1;
	          } else {
	            _i = i + 1 | 0;
	            continue ;
	            
	          }
	        } else {
	          return /* true */1;
	        }
	      }
	    };
	  };
	  if (needs_escape(0)) {
	    return Caml_string.bytes_to_string(Bytes.escaped(Caml_string.bytes_of_string(s)));
	  } else {
	    return s;
	  }
	}

	function index(s, c) {
	  return Bytes.index(Caml_string.bytes_of_string(s), c);
	}

	function rindex(s, c) {
	  return Bytes.rindex(Caml_string.bytes_of_string(s), c);
	}

	function index_from(s, i, c) {
	  return Bytes.index_from(Caml_string.bytes_of_string(s), i, c);
	}

	function rindex_from(s, i, c) {
	  return Bytes.rindex_from(Caml_string.bytes_of_string(s), i, c);
	}

	function contains(s, c) {
	  return Bytes.contains(Caml_string.bytes_of_string(s), c);
	}

	function contains_from(s, i, c) {
	  return Bytes.contains_from(Caml_string.bytes_of_string(s), i, c);
	}

	function rcontains_from(s, i, c) {
	  return Bytes.rcontains_from(Caml_string.bytes_of_string(s), i, c);
	}

	function uppercase(s) {
	  return Caml_string.bytes_to_string(Bytes.uppercase(Caml_string.bytes_of_string(s)));
	}

	function lowercase(s) {
	  return Caml_string.bytes_to_string(Bytes.lowercase(Caml_string.bytes_of_string(s)));
	}

	function capitalize(s) {
	  return Caml_string.bytes_to_string(Bytes.capitalize(Caml_string.bytes_of_string(s)));
	}

	function uncapitalize(s) {
	  return Caml_string.bytes_to_string(Bytes.uncapitalize(Caml_string.bytes_of_string(s)));
	}

	var compare = Caml_string.caml_string_compare;

	var fill = Bytes.fill;

	var blit = Bytes.blit_string;

	exports.make           = make;
	exports.init           = init;
	exports.copy           = copy;
	exports.sub            = sub;
	exports.fill           = fill;
	exports.blit           = blit;
	exports.concat         = concat;
	exports.iter           = iter;
	exports.iteri          = iteri;
	exports.map            = map;
	exports.mapi           = mapi;
	exports.trim           = trim;
	exports.escaped        = escaped;
	exports.index          = index;
	exports.rindex         = rindex;
	exports.index_from     = index_from;
	exports.rindex_from    = rindex_from;
	exports.contains       = contains;
	exports.contains_from  = contains_from;
	exports.rcontains_from = rcontains_from;
	exports.uppercase      = uppercase;
	exports.lowercase      = lowercase;
	exports.capitalize     = capitalize;
	exports.uncapitalize   = uncapitalize;
	exports.compare        = compare;
	/* No side effect */


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var Char                    = __webpack_require__(23);
	var List                    = __webpack_require__(2);
	var Curry                   = __webpack_require__(3);
	var Caml_obj                = __webpack_require__(6);
	var Caml_int32              = __webpack_require__(13);
	var Pervasives              = __webpack_require__(8);
	var Caml_string             = __webpack_require__(16);
	var Caml_builtin_exceptions = __webpack_require__(5);

	function make(n, c) {
	  var s = Caml_string.caml_create_string(n);
	  Caml_string.caml_fill_string(s, 0, n, c);
	  return s;
	}

	function init(n, f) {
	  var s = Caml_string.caml_create_string(n);
	  for(var i = 0 ,i_finish = n - 1 | 0; i <= i_finish; ++i){
	    s[i] = Curry._1(f, i);
	  }
	  return s;
	}

	var empty = [];

	function copy(s) {
	  var len = s.length;
	  var r = Caml_string.caml_create_string(len);
	  Caml_string.caml_blit_bytes(s, 0, r, 0, len);
	  return r;
	}

	function to_string(b) {
	  return Caml_string.bytes_to_string(copy(b));
	}

	function of_string(s) {
	  return copy(Caml_string.bytes_of_string(s));
	}

	function sub(s, ofs, len) {
	  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
	    throw [
	          Caml_builtin_exceptions.invalid_argument,
	          "String.sub / Bytes.sub"
	        ];
	  } else {
	    var r = Caml_string.caml_create_string(len);
	    Caml_string.caml_blit_bytes(s, ofs, r, 0, len);
	    return r;
	  }
	}

	function sub_string(b, ofs, len) {
	  return Caml_string.bytes_to_string(sub(b, ofs, len));
	}

	function extend(s, left, right) {
	  var len = (s.length + left | 0) + right | 0;
	  var r = Caml_string.caml_create_string(len);
	  var match = left < 0 ? /* tuple */[
	      -left | 0,
	      0
	    ] : /* tuple */[
	      0,
	      left
	    ];
	  var dstoff = match[1];
	  var srcoff = match[0];
	  var cpylen = Pervasives.min(s.length - srcoff | 0, len - dstoff | 0);
	  if (cpylen > 0) {
	    Caml_string.caml_blit_bytes(s, srcoff, r, dstoff, cpylen);
	  }
	  return r;
	}

	function fill(s, ofs, len, c) {
	  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
	    throw [
	          Caml_builtin_exceptions.invalid_argument,
	          "String.fill / Bytes.fill"
	        ];
	  } else {
	    return Caml_string.caml_fill_string(s, ofs, len, c);
	  }
	}

	function blit(s1, ofs1, s2, ofs2, len) {
	  if (len < 0 || ofs1 < 0 || ofs1 > (s1.length - len | 0) || ofs2 < 0 || ofs2 > (s2.length - len | 0)) {
	    throw [
	          Caml_builtin_exceptions.invalid_argument,
	          "Bytes.blit"
	        ];
	  } else {
	    return Caml_string.caml_blit_bytes(s1, ofs1, s2, ofs2, len);
	  }
	}

	function blit_string(s1, ofs1, s2, ofs2, len) {
	  if (len < 0 || ofs1 < 0 || ofs1 > (s1.length - len | 0) || ofs2 < 0 || ofs2 > (s2.length - len | 0)) {
	    throw [
	          Caml_builtin_exceptions.invalid_argument,
	          "String.blit / Bytes.blit_string"
	        ];
	  } else {
	    return Caml_string.caml_blit_string(s1, ofs1, s2, ofs2, len);
	  }
	}

	function iter(f, a) {
	  for(var i = 0 ,i_finish = a.length - 1 | 0; i <= i_finish; ++i){
	    Curry._1(f, a[i]);
	  }
	  return /* () */0;
	}

	function iteri(f, a) {
	  for(var i = 0 ,i_finish = a.length - 1 | 0; i <= i_finish; ++i){
	    Curry._2(f, i, a[i]);
	  }
	  return /* () */0;
	}

	function concat(sep, l) {
	  if (l) {
	    var hd = l[0];
	    var num = [0];
	    var len = [0];
	    List.iter((function (s) {
	            num[0] = num[0] + 1 | 0;
	            len[0] = len[0] + s.length | 0;
	            return /* () */0;
	          }), l);
	    var r = Caml_string.caml_create_string(len[0] + Caml_int32.imul(sep.length, num[0] - 1 | 0) | 0);
	    Caml_string.caml_blit_bytes(hd, 0, r, 0, hd.length);
	    var pos = [hd.length];
	    List.iter((function (s) {
	            Caml_string.caml_blit_bytes(sep, 0, r, pos[0], sep.length);
	            pos[0] = pos[0] + sep.length | 0;
	            Caml_string.caml_blit_bytes(s, 0, r, pos[0], s.length);
	            pos[0] = pos[0] + s.length | 0;
	            return /* () */0;
	          }), l[1]);
	    return r;
	  } else {
	    return empty;
	  }
	}

	function cat(a, b) {
	  return a.concat(b);
	}

	function is_space(param) {
	  var switcher = param - 9 | 0;
	  if (switcher > 4 || switcher < 0) {
	    if (switcher !== 23) {
	      return /* false */0;
	    } else {
	      return /* true */1;
	    }
	  } else if (switcher !== 2) {
	    return /* true */1;
	  } else {
	    return /* false */0;
	  }
	}

	function trim(s) {
	  var len = s.length;
	  var i = 0;
	  while(i < len && is_space(s[i])) {
	    i = i + 1 | 0;
	  };
	  var j = len - 1 | 0;
	  while(j >= i && is_space(s[j])) {
	    j = j - 1 | 0;
	  };
	  if (j >= i) {
	    return sub(s, i, (j - i | 0) + 1 | 0);
	  } else {
	    return empty;
	  }
	}

	function escaped(s) {
	  var n = 0;
	  for(var i = 0 ,i_finish = s.length - 1 | 0; i <= i_finish; ++i){
	    var match = s[i];
	    var tmp;
	    if (match >= 32) {
	      var switcher = match - 34 | 0;
	      tmp = switcher > 58 || switcher < 0 ? (
	          switcher >= 93 ? 4 : 1
	        ) : (
	          switcher > 57 || switcher < 1 ? 2 : 1
	        );
	    } else {
	      tmp = match >= 11 ? (
	          match !== 13 ? 4 : 2
	        ) : (
	          match >= 8 ? 2 : 4
	        );
	    }
	    n = n + tmp | 0;
	  }
	  if (n === s.length) {
	    return copy(s);
	  } else {
	    var s$prime = Caml_string.caml_create_string(n);
	    n = 0;
	    for(var i$1 = 0 ,i_finish$1 = s.length - 1 | 0; i$1 <= i_finish$1; ++i$1){
	      var c = s[i$1];
	      var exit = 0;
	      if (c >= 35) {
	        if (c !== 92) {
	          if (c >= 127) {
	            exit = 1;
	          } else {
	            s$prime[n] = c;
	          }
	        } else {
	          exit = 2;
	        }
	      } else if (c >= 32) {
	        if (c >= 34) {
	          exit = 2;
	        } else {
	          s$prime[n] = c;
	        }
	      } else if (c >= 14) {
	        exit = 1;
	      } else {
	        switch (c) {
	          case 8 : 
	              s$prime[n] = /* "\\" */92;
	              n = n + 1 | 0;
	              s$prime[n] = /* "b" */98;
	              break;
	          case 9 : 
	              s$prime[n] = /* "\\" */92;
	              n = n + 1 | 0;
	              s$prime[n] = /* "t" */116;
	              break;
	          case 10 : 
	              s$prime[n] = /* "\\" */92;
	              n = n + 1 | 0;
	              s$prime[n] = /* "n" */110;
	              break;
	          case 0 : 
	          case 1 : 
	          case 2 : 
	          case 3 : 
	          case 4 : 
	          case 5 : 
	          case 6 : 
	          case 7 : 
	          case 11 : 
	          case 12 : 
	              exit = 1;
	              break;
	          case 13 : 
	              s$prime[n] = /* "\\" */92;
	              n = n + 1 | 0;
	              s$prime[n] = /* "r" */114;
	              break;
	          
	        }
	      }
	      switch (exit) {
	        case 1 : 
	            s$prime[n] = /* "\\" */92;
	            n = n + 1 | 0;
	            s$prime[n] = 48 + (c / 100 | 0) | 0;
	            n = n + 1 | 0;
	            s$prime[n] = 48 + (c / 10 | 0) % 10 | 0;
	            n = n + 1 | 0;
	            s$prime[n] = 48 + c % 10 | 0;
	            break;
	        case 2 : 
	            s$prime[n] = /* "\\" */92;
	            n = n + 1 | 0;
	            s$prime[n] = c;
	            break;
	        
	      }
	      n = n + 1 | 0;
	    }
	    return s$prime;
	  }
	}

	function map(f, s) {
	  var l = s.length;
	  if (l) {
	    var r = Caml_string.caml_create_string(l);
	    for(var i = 0 ,i_finish = l - 1 | 0; i <= i_finish; ++i){
	      r[i] = Curry._1(f, s[i]);
	    }
	    return r;
	  } else {
	    return s;
	  }
	}

	function mapi(f, s) {
	  var l = s.length;
	  if (l) {
	    var r = Caml_string.caml_create_string(l);
	    for(var i = 0 ,i_finish = l - 1 | 0; i <= i_finish; ++i){
	      r[i] = Curry._2(f, i, s[i]);
	    }
	    return r;
	  } else {
	    return s;
	  }
	}

	function uppercase(s) {
	  return map(Char.uppercase, s);
	}

	function lowercase(s) {
	  return map(Char.lowercase, s);
	}

	function apply1(f, s) {
	  if (s.length) {
	    var r = copy(s);
	    r[0] = Curry._1(f, s[0]);
	    return r;
	  } else {
	    return s;
	  }
	}

	function capitalize(s) {
	  return apply1(Char.uppercase, s);
	}

	function uncapitalize(s) {
	  return apply1(Char.lowercase, s);
	}

	function index_rec(s, lim, _i, c) {
	  while(true) {
	    var i = _i;
	    if (i >= lim) {
	      throw Caml_builtin_exceptions.not_found;
	    } else if (s[i] === c) {
	      return i;
	    } else {
	      _i = i + 1 | 0;
	      continue ;
	      
	    }
	  };
	}

	function index(s, c) {
	  return index_rec(s, s.length, 0, c);
	}

	function index_from(s, i, c) {
	  var l = s.length;
	  if (i < 0 || i > l) {
	    throw [
	          Caml_builtin_exceptions.invalid_argument,
	          "String.index_from / Bytes.index_from"
	        ];
	  } else {
	    return index_rec(s, l, i, c);
	  }
	}

	function rindex_rec(s, _i, c) {
	  while(true) {
	    var i = _i;
	    if (i < 0) {
	      throw Caml_builtin_exceptions.not_found;
	    } else if (s[i] === c) {
	      return i;
	    } else {
	      _i = i - 1 | 0;
	      continue ;
	      
	    }
	  };
	}

	function rindex(s, c) {
	  return rindex_rec(s, s.length - 1 | 0, c);
	}

	function rindex_from(s, i, c) {
	  if (i < -1 || i >= s.length) {
	    throw [
	          Caml_builtin_exceptions.invalid_argument,
	          "String.rindex_from / Bytes.rindex_from"
	        ];
	  } else {
	    return rindex_rec(s, i, c);
	  }
	}

	function contains_from(s, i, c) {
	  var l = s.length;
	  if (i < 0 || i > l) {
	    throw [
	          Caml_builtin_exceptions.invalid_argument,
	          "String.contains_from / Bytes.contains_from"
	        ];
	  } else {
	    try {
	      index_rec(s, l, i, c);
	      return /* true */1;
	    }
	    catch (exn){
	      if (exn === Caml_builtin_exceptions.not_found) {
	        return /* false */0;
	      } else {
	        throw exn;
	      }
	    }
	  }
	}

	function contains(s, c) {
	  return contains_from(s, 0, c);
	}

	function rcontains_from(s, i, c) {
	  if (i < 0 || i >= s.length) {
	    throw [
	          Caml_builtin_exceptions.invalid_argument,
	          "String.rcontains_from / Bytes.rcontains_from"
	        ];
	  } else {
	    try {
	      rindex_rec(s, i, c);
	      return /* true */1;
	    }
	    catch (exn){
	      if (exn === Caml_builtin_exceptions.not_found) {
	        return /* false */0;
	      } else {
	        throw exn;
	      }
	    }
	  }
	}

	var compare = Caml_obj.caml_compare;

	var unsafe_to_string = Caml_string.bytes_to_string;

	var unsafe_of_string = Caml_string.bytes_of_string;

	exports.make             = make;
	exports.init             = init;
	exports.empty            = empty;
	exports.copy             = copy;
	exports.of_string        = of_string;
	exports.to_string        = to_string;
	exports.sub              = sub;
	exports.sub_string       = sub_string;
	exports.extend           = extend;
	exports.fill             = fill;
	exports.blit             = blit;
	exports.blit_string      = blit_string;
	exports.concat           = concat;
	exports.cat              = cat;
	exports.iter             = iter;
	exports.iteri            = iteri;
	exports.map              = map;
	exports.mapi             = mapi;
	exports.trim             = trim;
	exports.escaped          = escaped;
	exports.index            = index;
	exports.rindex           = rindex;
	exports.index_from       = index_from;
	exports.rindex_from      = rindex_from;
	exports.contains         = contains;
	exports.contains_from    = contains_from;
	exports.rcontains_from   = rcontains_from;
	exports.uppercase        = uppercase;
	exports.lowercase        = lowercase;
	exports.capitalize       = capitalize;
	exports.uncapitalize     = uncapitalize;
	exports.compare          = compare;
	exports.unsafe_to_string = unsafe_to_string;
	exports.unsafe_of_string = unsafe_of_string;
	/* No side effect */


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var Caml_string             = __webpack_require__(16);
	var Caml_builtin_exceptions = __webpack_require__(5);

	function chr(n) {
	  if (n < 0 || n > 255) {
	    throw [
	          Caml_builtin_exceptions.invalid_argument,
	          "Char.chr"
	        ];
	  } else {
	    return n;
	  }
	}

	function escaped(c) {
	  var exit = 0;
	  if (c >= 40) {
	    if (c !== 92) {
	      exit = c >= 127 ? 1 : 2;
	    } else {
	      return "\\\\";
	    }
	  } else if (c >= 32) {
	    if (c >= 39) {
	      return "\\'";
	    } else {
	      exit = 2;
	    }
	  } else if (c >= 14) {
	    exit = 1;
	  } else {
	    switch (c) {
	      case 8 : 
	          return "\\b";
	      case 9 : 
	          return "\\t";
	      case 10 : 
	          return "\\n";
	      case 0 : 
	      case 1 : 
	      case 2 : 
	      case 3 : 
	      case 4 : 
	      case 5 : 
	      case 6 : 
	      case 7 : 
	      case 11 : 
	      case 12 : 
	          exit = 1;
	          break;
	      case 13 : 
	          return "\\r";
	      
	    }
	  }
	  switch (exit) {
	    case 1 : 
	        var s = new Array(4);
	        s[0] = /* "\\" */92;
	        s[1] = 48 + (c / 100 | 0) | 0;
	        s[2] = 48 + (c / 10 | 0) % 10 | 0;
	        s[3] = 48 + c % 10 | 0;
	        return Caml_string.bytes_to_string(s);
	    case 2 : 
	        var s$1 = new Array(1);
	        s$1[0] = c;
	        return Caml_string.bytes_to_string(s$1);
	    
	  }
	}

	function lowercase(c) {
	  if (c >= /* "A" */65 && c <= /* "Z" */90 || c >= /* "\192" */192 && c <= /* "\214" */214 || c >= /* "\216" */216 && c <= /* "\222" */222) {
	    return c + 32 | 0;
	  } else {
	    return c;
	  }
	}

	function uppercase(c) {
	  if (c >= /* "a" */97 && c <= /* "z" */122 || c >= /* "\224" */224 && c <= /* "\246" */246 || c >= /* "\248" */248 && c <= /* "\254" */254) {
	    return c - 32 | 0;
	  } else {
	    return c;
	  }
	}

	function compare(c1, c2) {
	  return c1 - c2 | 0;
	}

	exports.chr       = chr;
	exports.escaped   = escaped;
	exports.lowercase = lowercase;
	exports.uppercase = uppercase;
	exports.compare   = compare;
	/* No side effect */


/***/ }),
/* 24 */
/***/ (function(module, exports) {

	'use strict';


	function is_nil_undef(x) {
	  if (x === null) {
	    return /* true */1;
	  } else {
	    return +(x === undefined);
	  }
	}

	function null_undefined_to_opt(x) {
	  if (x === null || x === undefined) {
	    return /* None */0;
	  } else {
	    return /* Some */[x];
	  }
	}

	function undefined_to_opt(x) {
	  if (x === undefined) {
	    return /* None */0;
	  } else {
	    return /* Some */[x];
	  }
	}

	function null_to_opt(x) {
	  if (x === null) {
	    return /* None */0;
	  } else {
	    return /* Some */[x];
	  }
	}

	function option_get(x) {
	  if (x) {
	    return x[0];
	  } else {
	    return undefined;
	  }
	}

	function option_get_unwrap(x) {
	  if (x) {
	    return x[0][1];
	  } else {
	    return undefined;
	  }
	}

	exports.is_nil_undef          = is_nil_undef;
	exports.null_undefined_to_opt = null_undefined_to_opt;
	exports.undefined_to_opt      = undefined_to_opt;
	exports.null_to_opt           = null_to_opt;
	exports.option_get            = option_get;
	exports.option_get_unwrap     = option_get_unwrap;
	/* No side effect */


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	// Generated by BUCKLESCRIPT VERSION 1.9.3, PLEASE EDIT WITH CARE
	'use strict';

	var Std     = __webpack_require__(1);
	var Curry   = __webpack_require__(3);
	var Js_null = __webpack_require__(26);

	function parseHeaders(headers) {
	  return Std.Dict[/* fromList */1](Std.List[/* filterMap */27]((function (s) {
	                    var match = Std.$$String[/* split */23](":", s);
	                    if (match) {
	                      var match$1 = match[1];
	                      if (match$1 && !match$1[1]) {
	                        return /* Some */[/* tuple */[
	                                  Std.$$String[/* trim */14](match[0]),
	                                  Std.$$String[/* trim */14](match$1[0])
	                                ]];
	                      } else {
	                        return /* None */0;
	                      }
	                    } else {
	                      return /* None */0;
	                    }
	                  }), Std.$$String[/* split */23]("\n", headers)));
	}

	function make(pub, userHeaders, body, url) {
	  var partial_arg = Std.Task[/* make */0];
	  return (function (param, param$1) {
	      return partial_arg((function (fail, succeed) {
	                    var request = new XMLHttpRequest();
	                    request.open(pub, url);
	                    var headers = Std.Dict[/* setDefault */6]("Content-Type", "application/json", userHeaders);
	                    Std.Dict[/* iter */9]((function (param, param$1) {
	                              request.setRequestHeader(param, param$1);
	                              return /* () */0;
	                            }))(headers);
	                    var onReady = function () {
	                      var readyState = request.readyState;
	                      if (readyState === 4) {
	                        var statusText = request.statusText;
	                        var responseText = request.responseText;
	                        var responseHeaders = parseHeaders(request.getAllResponseHeaders());
	                        console.log("Headers", responseHeaders);
	                        var status = request.status;
	                        if (status !== 0) {
	                          if (status < 200) {
	                            return Curry._1(fail, /* BadResponse */[
	                                        status,
	                                        responseText
	                                      ]);
	                          } else if (status >= 300) {
	                            return Curry._1(fail, /* BadResponse */[
	                                        status,
	                                        responseText
	                                      ]);
	                          } else {
	                            return Curry._1(succeed, /* record */[
	                                        /* status */status,
	                                        /* statusText */statusText,
	                                        /* headers */responseHeaders,
	                                        /* body */responseText
	                                      ]);
	                          }
	                        } else {
	                          return Curry._1(fail, /* NetworkError */1);
	                        }
	                      } else {
	                        return 0;
	                      }
	                    };
	                    request.onreadystatechange = onReady;
	                    request.ontimeout = (function () {
	                        return Curry._1(fail, /* Timeout */0);
	                      });
	                    request.send(Js_null.from_opt(body));
	                    return /* () */0;
	                  }), param, param$1);
	    });
	}

	function get($staropt$star, url) {
	  var headers = $staropt$star ? $staropt$star[0] : Std.Dict[/* empty */0];
	  return make("GET", headers, /* None */0, url);
	}

	function post($staropt$star, body, url) {
	  var headers = $staropt$star ? $staropt$star[0] : Std.Dict[/* empty */0];
	  return make("POST", headers, /* Some */[body], url);
	}

	function put($staropt$star, body, url) {
	  var headers = $staropt$star ? $staropt$star[0] : Std.Dict[/* empty */0];
	  return make("PUT", headers, /* Some */[body], url);
	}

	function $$delete($staropt$star, url) {
	  var headers = $staropt$star ? $staropt$star[0] : Std.Dict[/* empty */0];
	  return make("DELETE", headers, /* None */0, url);
	}

	exports.get      = get;
	exports.post     = post;
	exports.put      = put;
	exports.$$delete = $$delete;
	/* No side effect */


/***/ }),
/* 26 */
/***/ (function(module, exports) {

	'use strict';


	function bind(x, f) {
	  if (x !== null) {
	    return f(x);
	  } else {
	    return null;
	  }
	}

	function iter(x, f) {
	  if (x !== null) {
	    return f(x);
	  } else {
	    return /* () */0;
	  }
	}

	function from_opt(x) {
	  if (x) {
	    return x[0];
	  } else {
	    return null;
	  }
	}

	exports.bind     = bind;
	exports.iter     = iter;
	exports.from_opt = from_opt;
	/* No side effect */


/***/ })
/******/ ]);